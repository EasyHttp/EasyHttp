<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JsonFx</name>
    </assembly>
    <members>
        <member name="T:JsonFx.About">
            <summary>
            JsonFx metadata
            </summary>
        </member>
        <member name="M:JsonFx.About.#ctor(System.Reflection.Assembly)">
            <summary>
            Ctor
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="T:JsonFx.Bson.BsonWriter.BsonFormatter">
            <summary>
            Outputs BSON bytes from an input stream of tokens
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.IBinaryFormatter`1">
            <summary>
            Outputs text from an input stream of JSON tokens
            </summary>
            <typeparam name="T">token type</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IBinaryFormatter`1.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}},System.IO.Stream)">
            <summary>
            Formats the token sequence to the output writer
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Serialization.IBinaryFormatter`1.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}})">
            <summary>
            Formats the token sequence as a string
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonWriter.BsonFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Formats the token sequence as a string
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonWriter.BsonFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.IO.Stream)">
            <summary>
            Formats the token sequence to the output writer
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonWriter.BsonFormatter.WriteDocument(System.IO.BinaryWriter,JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Emits a document (or array) to the binary stream
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:JsonFx.Bson.BsonWriter.BsonFormatter.WriteElement(System.IO.BinaryWriter,JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.String)">
            <summary>
            Emits a single element to the binary stream
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
            <param name="ename"></param>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:JsonFx.Bson.BsonWriter.BsonFormatter.WriteString(System.IO.BinaryWriter,System.String,System.Boolean)">
            <summary>
            Emits a string value
            </summary>
            <param name="writer"></param>
            <param name="token"></param>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:JsonFx.Bson.BsonWriter.BsonFormatter.WriteBinary(System.IO.BinaryWriter,JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType})">
            <summary>
            Emits a binary value
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
            <returns>number of bytes written</returns>
        </member>
        <member name="M:JsonFx.Bson.BsonWriter.BsonFormatter.WriteCodeWithScope(System.IO.BinaryWriter,JsonFx.Bson.BsonCodeWithScope)">
            <summary>
            Emits a code_w_s value
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
            <returns>number of bytes written</returns>
        </member>
        <member name="T:JsonFx.Bson.BsonReader.BsonTokenizer">
            <summary>
            Generates a sequence of tokens from BSON bytes
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.IBinaryTokenizer`1">
            <summary>
            Generates a sequence of tokens from a sequence of characters
            </summary>
            <typeparam name="T">token type</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IBinaryTokenizer`1.GetTokens(System.IO.Stream)">
            <summary>
            Tokenizes the input sequence into tokens
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.IBinaryTokenizer`1.GetTokens(System.Byte[])">
            <summary>
            Tokenizes the input sequence into tokens
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Serialization.IBinaryTokenizer`1.Index">
            <summary>
            Gets the current position of the underlying input character sequence
            </summary>
            <remarks>
            Tokenizers not tracking index should return -1.
            </remarks>
        </member>
        <member name="M:JsonFx.Bson.BsonReader.BsonTokenizer.GetTokens(System.IO.Stream)">
            <summary>
            Gets a token sequence from the TextReader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonReader.BsonTokenizer.GetTokens(System.Byte[])">
            <summary>
            Gets a token sequence from the string
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonReader.BsonTokenizer.GetTokens(System.IO.BinaryReader)">
            <summary>
            Gets a token sequence from the reader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Bson.BsonReader.BsonTokenizer.Index">
            <summary>
            Gets the current position of the underlying stream
            </summary>
        </member>
        <member name="T:JsonFx.Bson.BsonMD5">
            <summary>
            BSON MD5 Datatype
            </summary>
        </member>
        <member name="M:JsonFx.Bson.BsonMD5.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonMD5.#ctor(System.Byte[])">
            <summary>
            Ctor
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonMD5.#ctor(System.Guid)">
            <summary>
            Ctor
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonMD5.op_Explicit(JsonFx.Bson.BsonMD5)~System.Guid">
            <summary>
            Converts MD5 to Guid
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JsonFx.Bson.BsonMD5.op_Explicit(System.Guid)~JsonFx.Bson.BsonMD5" -->
        <member name="M:JsonFx.Bson.BsonMD5.ToString">
            <summary>
            Converts MD5 to Guid
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonMD5.GetHashCode">
            <summary>
            Gets the hashcode of the underlying Guid
            </summary>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Bson.BsonCodeWithScope">
            <summary>
            BSON JavaScript Code With Scope Datatype
            </summary>
        </member>
        <member name="T:JsonFx.Bson.BsonJavaScriptCode">
            <summary>
            BSON JavaScript Code Datatype
            </summary>
        </member>
        <member name="M:JsonFx.Bson.BsonJavaScriptCode.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="code"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonJavaScriptCode.op_Explicit(JsonFx.Bson.BsonJavaScriptCode)~System.String">
            <summary>
            Converts JavaScriptCode to string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JsonFx.Bson.BsonJavaScriptCode.op_Explicit(System.String)~JsonFx.Bson.BsonJavaScriptCode" -->
        <member name="M:JsonFx.Bson.BsonJavaScriptCode.ToString">
            <summary>
            Converts JavaScriptCode to string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonJavaScriptCode.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Bson.BsonSymbol">
            <summary>
            BSON Symbol Datatype
            </summary>
        </member>
        <member name="M:JsonFx.Bson.BsonSymbol.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="code"></param>
        </member>
        <member name="M:JsonFx.Bson.BsonSymbol.op_Explicit(JsonFx.Bson.BsonSymbol)~System.String">
            <summary>
            Converts Symbol to string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JsonFx.Bson.BsonSymbol.op_Explicit(System.String)~JsonFx.Bson.BsonSymbol" -->
        <member name="M:JsonFx.Bson.BsonSymbol.ToString">
            <summary>
            Converts Symbol to string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonSymbol.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Bson.BsonDBPointer">
            <summary>
            BSON DBPointer Datatype (Deprecated)
            </summary>
        </member>
        <member name="T:JsonFx.Bson.BsonObjectID">
            <summary>
            Immutable BSON ObjectID Datatype
            </summary>
            <remarks>
            http://www.mongodb.org/display/DOCS/Object+IDs#ObjectIDs-TheBSONObjectIdDatatype
            </remarks>
        </member>
        <member name="M:JsonFx.Bson.BsonObjectID.#ctor(System.Byte[])">
            <summary>
            Ctor
            </summary>
            <param name="bytes">12-byte object ID</param>
        </member>
        <member name="M:JsonFx.Bson.BsonObjectID.#ctor(System.DateTime,System.Int32,System.Int32,System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="time">4-byte seconds since Unit epoch</param>
            <param name="machine">3-byte machine ID</param>
            <param name="pid">2-byte process ID</param>
            <param name="inc">3-byte counter</param>
        </member>
        <member name="M:JsonFx.Bson.BsonObjectID.op_Explicit(JsonFx.Bson.BsonObjectID)~System.String">
            <summary>
            Converts an ObjectID to a hex string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonObjectID.op_Explicit(System.String)~JsonFx.Bson.BsonObjectID">
            <summary>
            Converts a hex string to an ObjectID
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonObjectID.op_Explicit(JsonFx.Bson.BsonObjectID)~System.Byte[]">
            <summary>
            Converts an ObjectID to a byte array
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonObjectID.op_Explicit(System.Byte[])~JsonFx.Bson.BsonObjectID">
            <summary>
            Converts a byte array to an ObjectID
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonObjectID.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Bson.BsonObjectID.Time">
            <summary>
            Gets the time associated with this ObjectID
            </summary>
        </member>
        <member name="P:JsonFx.Bson.BsonObjectID.Machine">
            <summary>
            Gets the machine id associated with this ObjectID
            </summary>
        </member>
        <member name="P:JsonFx.Bson.BsonObjectID.Pid">
            <summary>
            Gets the process id associated with this ObjectID
            </summary>
        </member>
        <member name="P:JsonFx.Bson.BsonObjectID.Inc">
            <summary>
            Gets the counter associated with this ObjectID
            </summary>
        </member>
        <member name="T:JsonFx.Bson.BsonBinary">
            <summary>
            Generic binary holder
            </summary>
            <remarks>
            http://api.mongodb.org/java/2.0/org/bson/types/Binary.html
            </remarks>
        </member>
        <member name="M:JsonFx.Bson.BsonBinary.#ctor(JsonFx.Bson.BsonBinarySubtype,System.Byte[])">
            <summary>
            Ctor
            </summary>
            <param name="subtype">binary type code</param>
            <param name="bytes">byte date</param>
        </member>
        <member name="M:JsonFx.Bson.BsonBinary.op_Explicit(JsonFx.Bson.BsonBinary)~System.String">
            <summary>
            Converts an ObjectID to a hex string
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonBinary.op_Explicit(System.String)~JsonFx.Bson.BsonBinary">
            <summary>
            Converts a hex string to an ObjectID
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonBinary.op_Explicit(JsonFx.Bson.BsonBinary)~System.Byte[]">
            <summary>
            Converts an ObjectID to a byte array
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonBinary.op_Explicit(System.Byte[])~JsonFx.Bson.BsonBinary">
            <summary>
            Converts a byte array to an ObjectID
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonBinary.GetHashCode">
            <summary>
            Gets the hashcode of the underlying string
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Bson.BsonBinary.GetHexDigit(System.Int32)">
            <summary>
            Gets a 4-bit number as a hex digit
            </summary>
            <param name="i">0-15</param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Bson.BsonBinary.Data">
            <summary>
            Gets the binary type code
            </summary>
        </member>
        <member name="P:JsonFx.Bson.BsonBinary.Type">
            <summary>
            Gets the binary type code
            </summary>
        </member>
        <member name="P:JsonFx.Bson.BsonBinary.Item(System.Int32)">
            <summary>
            Gets the byte at the given index
            </summary>
        </member>
        <member name="P:JsonFx.Bson.BsonBinary.Count">
            <summary>
            Gets the length of the binary data
            </summary>
        </member>
        <member name="T:JsonFx.Bson.IBsonFormattable">
            <summary>
            Designates a type as being able to format itself to raw BSON bytes
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.IBinaryFormattable`1">
            <summary>
            Designates a type as being able to format itself to raw bytes
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.IBinaryFormattable`1.Format(JsonFx.Serialization.IBinaryFormatter{`0},System.IO.BinaryWriter)">
            <summary>
            Writes custom format to the output using either tokens or bytes
            </summary>
            <param name="formatter"></param>
            <param name="writer"></param>
            <returns>total number of bytes written</returns>
        </member>
        <member name="M:JsonFx.Bson.IBsonFormattable.GetElementType">
            <summary>
            Determines the corresponding BSON element type
            </summary>
            <returns></returns>
        </member>
        <member name="T:JsonFx.CodeGen.FactoryDelegate">
            <summary>
            Generalized delegate for invoking a constructor
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.CodeGen.ProxyDelegate">
            <summary>
            Generalized delegate for invoking a method
            </summary>
            <param name="target">the instance object</param>
            <param name="args">the method parameters</param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.CodeGen.GetterDelegate">
            <summary>
            Generalized delegate for getting a field or property value
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.CodeGen.SetterDelegate">
            <summary>
            Generalized delegate for setting a field or property value
            </summary>
            <param name="target"></param>
            <param name="value"></param>
        </member>
        <member name="T:JsonFx.Model.ModelAnalyzer">
            <summary>
            Consumes a sequence of tokens to produce an object graph optionally coerced to a given type
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.ITokenAnalyzer`1">
            <summary>
            Consumes a sequence of tokens to produce a sequence of objects, optionally coerced to a given type
            </summary>
            <typeparam name="T">token type</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.ITokenAnalyzer`1.Analyze(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}})">
            <summary>
            Parses the token sequence
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.ITokenAnalyzer`1.Analyze(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}},System.Type)">
            <summary>
            Parses the token sequence, optionally coercing the result to Type targetType
            </summary>
            <param name="tokens"></param>
            <param name="targetType">optional type for coercion (null if not specified)</param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.ITokenAnalyzer`1.Analyze``1(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}})">
            <summary>
            Parses the token sequence, coercing the result to Type TResult
            </summary>
            <typeparam name="TResult">optional type for coercion (null if not specified)</typeparam>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.ITokenAnalyzer`1.Analyze``1(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}},``0)">
            <summary>
            Parses the token stream coercing the result to TResult (type inferred from <paramref name="ignored"/>)
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="tokens"></param>
            <param name="ignored">an example value used solely for Type inference</param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelAnalyzer.#ctor(JsonFx.Serialization.DataReaderSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Model.ModelAnalyzer.Analyze(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Parses the token stream coercing the result targetType
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelAnalyzer.Analyze(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.Type)">
            <summary>
            Parses the token stream coercing the result to targetType
            </summary>
            <param name="tokens"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelAnalyzer.Analyze``1(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Parses the token stream coercing the result to TResult
            </summary>
            <typeparam name="TResult">the result target type</typeparam>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelAnalyzer.Analyze``1(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},``0)">
            <summary>
            Parses the token stream coercing the result to TResult (inferred from <paramref name="ignored"/>)
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="tokens"></param>
            <param name="ignored">an example value used solely for Type inference</param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Model.ModelGrammar">
            <summary>
            Common Model Language grammar helper
            </summary>
            <remarks>
            Simplifies and guides syntax, and provides a set of reusable tokens to reduce redundant token instantiations
            </remarks>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenArrayBegin(System.String)">
            <summary>
            Marks the beginning of an array
            </summary>
            <param name="name">the local name of the array</param>
            <returns>ArrayBegin Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenArrayBegin(System.String,System.String,System.String)">
            <summary>
            Marks the beginning of an array
            </summary>
            <param name="name">the local name of the array</param>
            <param name="namespaceUri">the namespace of the document</param>
            <returns>ArrayBegin Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenArrayBegin(JsonFx.Serialization.DataName)">
            <summary>
            Marks the beginning of an array
            </summary>
            <param name="name">the name of the array</param>
            <returns>ArrayBegin Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenObjectBegin(System.String)">
            <summary>
            Marks the beginning of an object
            </summary>
            <param name="name">the local name of the object</param>
            <returns>ObjectBegin Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenObjectBegin(JsonFx.Serialization.DataName)">
            <summary>
            Marks the beginning of an object
            </summary>
            <param name="name">the name of the object</param>
            <returns>ObjectBegin Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenProperty(System.Object)">
            <summary>
            Marks the beginning of an object property
            </summary>
            <param name="localName">the local name of the property</param>
            <returns>PropertyKey Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenProperty(System.String)">
            <summary>
            Marks the beginning of an object property
            </summary>
            <param name="localName">the local name of the property</param>
            <returns>PropertyKey Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenProperty(JsonFx.Serialization.DataName)">
            <summary>
            Marks the beginning of an object property
            </summary>
            <param name="name">the name of the property</param>
            <returns>PropertyKey Token</returns>
        </member>
        <member name="M:JsonFx.Model.ModelGrammar.TokenPrimitive(System.Object)">
            <summary>
            A simple scalar value (typically serialized as a single primitive value)
            </summary>
            <param name="value"></param>
            <returns>Value Token</returns>
        </member>
        <member name="T:JsonFx.Model.ModelReader">
            <summary>
            Provides base implementation for standard deserializers
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.DataReader`1">
            <summary>
            Provides base implementation for standard deserializers
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.IDataReader">
            <summary>
            A common interface for data deserializers
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read``1(System.IO.TextReader,``0)">
            <summary>
            Deserializes a single object from the given input
            </summary>
            <param name="input">the input reader</param>
            <param name="ignored">a value used to trigger Type inference for <typeparamref name="TResult"/> (e.g. for deserializing anonymous objects)</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read``1(System.IO.TextReader)">
            <summary>
            Deserializes a single object from the given input
            </summary>
            <param name="input">the input reader</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read(System.IO.TextReader)">
            <summary>
            Serializes the data to the given output
            </summary>
            <param name="input">the input reader</param>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read(System.IO.TextReader,System.Type)">
            <summary>
            Deserializes a single object from the given input
            </summary>
            <param name="input">the input reader</param>
            <param name="targetType">the expected type of the serialized data</param>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read``1(System.String,``0)">
            <summary>
            Deserializes a single object from the given input
            </summary>
            <param name="input">the input text</param>
            <param name="ignored">a value used to trigger Type inference for <typeparamref name="TResult"/> (e.g. for deserializing anonymous objects)</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read``1(System.String)">
            <summary>
            Deserializes a single object from the given input
            </summary>
            <param name="input">the input text</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read(System.String)">
            <summary>
            Deserializes a single object from the given input
            </summary>
            <param name="input">the input text</param>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.Read(System.String,System.Type)">
            <summary>
            Deserializes a single object from the given input
            </summary>
            <param name="input">the input text</param>
            <param name="targetType">the expected type of the serialized data</param>
        </member>
        <member name="M:JsonFx.Serialization.IDataReader.ReadMany(System.IO.TextReader)">
            <summary>
            Deserializes a potentially endless sequence of objects from a stream source
            </summary>
            <param name="input"></param>
            <returns></returns>
            <remarks>
            character stream => token stream => object stream
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.IDataReader.ContentType">
            <summary>
            Gets the supported content type of the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.IDataReader.Settings">
            <summary>
            Gets the settings used for deserialization
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.#ctor(JsonFx.Serialization.DataReaderSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read``1(System.IO.TextReader,``0)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input reader</param>
            <param name="ignored">a value used to trigger Type inference for <typeparamref name="TResult"/> (e.g. for deserializing anonymous objects)</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read``1(System.IO.TextReader)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input reader</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read(System.IO.TextReader)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input reader</param>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read(System.IO.TextReader,System.Type)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input reader</param>
            <param name="targetType">the expected type of the serialized data</param>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read``1(System.String,``0)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input text</param>
            <param name="ignored">a value used to trigger Type inference for <typeparamref name="TResult"/> (e.g. for deserializing anonymous objects)</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read``1(System.String)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input text</param>
            <typeparam name="TResult">the expected type of the serialized data</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read(System.String)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input text</param>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.Read(System.String,System.Type)">
            <summary>
            Deserializes the data from the given input
            </summary>
            <param name="input">the input text</param>
            <param name="targetType">the expected type of the serialized data</param>
        </member>
        <member name="M:JsonFx.Serialization.DataReader`1.ReadMany(System.IO.TextReader)">
            <summary>
            Deserializes a potentially endless sequence of objects from a stream source
            </summary>
            <param name="input">a streamed source of objects</param>
            <returns>a sequence of objects</returns>
            <remarks>
            character stream => token stream => object stream
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.DataReader`1.ContentType">
            <summary>
            Gets the supported content type of the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataReader`1.Settings">
            <summary>
            Gets the settings used for deserialization
            </summary>
        </member>
        <member name="M:JsonFx.Model.ModelReader.#ctor(JsonFx.Serialization.DataReaderSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="T:JsonFx.Model.ModelSubsequencer">
            <summary>
            Extension methods for selecting subsequences of sequences of tokens
            </summary>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.IsPrimitive(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Determines if the sequence represents a primitive
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.IsObject(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Determines if the sequence represents an object
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.HasProperty(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.Func{JsonFx.Serialization.DataName,System.Boolean})">
            <summary>
            Determines if the root object has any properties which satisfies the name <paramref name="predicate"/>
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns>true if any properties match the predicate</returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.Property(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},JsonFx.Serialization.DataName)">
            <summary>
            Gets all properties of the root object
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns>all properties for the object</returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.Properties(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Gets all properties of the root object
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns>all properties for the object</returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.Properties(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.Func{JsonFx.Serialization.DataName,System.Boolean})">
            <summary>
            Gets the properties of the root object which satisfies the <paramref name="predicate"/>
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns>matching properties for the root object</returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.PropertiesIterator(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.Func{JsonFx.Serialization.DataName,System.Boolean})">
            <summary>
            Gets the properties of the root object which satisfies the <paramref name="predicate"/>
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns>matching properties for the root object</returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.IsArray(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Determines if the sequence represents an array
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.ArrayItems(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Gets all the items of the array
            </summary>
            <param name="source"></param>
            <returns>all items of the array</returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.ArrayItems(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.Func{System.Int32,System.Boolean})">
            <summary>
            Gets the items of the root array with indexes satisfying the <paramref name="predicate"/>
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns>items of the root array which statisfy the predicate</returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.ArrayItemsIterator(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.Func{System.Int32,System.Boolean})">
            <summary>
            ArrayItems iterator
            </summary>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.Descendants(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Gets all descendant values below the current root
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.DescendantsIterator(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Descendants iterator
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.DescendantsAndSelf(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Gets all descendant values below the current root, as well as the current root
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.DescendantsAndSelfIterator(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            DescendantsAndSelf iterator
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.SplitValues(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Covers the sitation where a stream of sequences may be back to back
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.SpliceNextValueLazy(JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Splices out the sequence for the next complete value (object, array, primitive)
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.SpliceNextValue(JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Splices out the sequence for the next complete value (object, array, primitive)
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelSubsequencer.SkipNextValue(JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Skips over the next complete value (object, array, primitive)
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Model.ModelTokenType">
            <summary>
            Common Model Language tokens
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Model.ModelTokenType.None" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Model.ModelTokenType.ObjectBegin" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Model.ModelTokenType.ObjectEnd" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Model.ModelTokenType.ArrayBegin" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Model.ModelTokenType.ArrayEnd" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Model.ModelTokenType.Property" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Model.ModelTokenType.Primitive" -->
        <member name="T:JsonFx.Model.ModelWalker">
            <summary>
            Generates a sequence of tokens from an object graph
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.IObjectWalker`1">
            <summary>
            Generates a sequence of tokens from an object graph
            </summary>
            <typeparam name="T">token type</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IObjectWalker`1.GetTokens(System.Object)">
            <summary>
            Generates a sequence of tokens representing the value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Model.ModelWalker.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Model.ModelWalker.GetTokens(System.Object)">
            <summary>
            Generates a sequence of tokens representing the value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Model.Filters.ModelFilter`1">
            <summary>
            Allows a mechanism for manipulating JSON serialization
            </summary>
            <typeparam name="T">Defines the type this filter reads/writes</typeparam>
        </member>
        <member name="T:JsonFx.Serialization.Filters.DataFilter`2">
            <summary>
            Partially implements an IDataFilter
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.Filters.IDataFilter`2">
            <summary>
            Allows a mechanism for manipulating serialization
            </summary>
            <typeparam name="TTokenType">Defines the type of token stream this filter understands</typeparam>
            <typeparam name="TResult">Defines the type this filter reads/writes</typeparam>
        </member>
        <member name="T:JsonFx.Serialization.Filters.IDataFilter`1">
            <summary>
            Allows a mechanism for manipulating serialization
            </summary>
            <typeparam name="TTokenType">Defines the type of token stream this filter understands</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.Filters.IDataFilter`1.TryRead(JsonFx.Serialization.DataReaderSettings,JsonFx.IO.IStream{JsonFx.Serialization.Token{`0}},System.Object@)">
            <summary>
            Allows a class to act as a factory for a type via input Token&lt;T&gt; sequence
            </summary>
            <param name="tokens">input tokens</param>
            <param name="value"></param>
            <returns>true if value was generated</returns>
        </member>
        <member name="M:JsonFx.Serialization.Filters.IDataFilter`1.TryWrite(JsonFx.Serialization.DataWriterSettings,System.Object,System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}}@)">
            <summary>
            Allows a class to serialize a type as Token&lt;T&gt; sequence
            </summary>
            <param name="value"></param>
            <param name="tokens"></param>
            <returns>true if value was consumed</returns>
        </member>
        <member name="M:JsonFx.Serialization.Filters.IDataFilter`2.TryRead(JsonFx.Serialization.DataReaderSettings,JsonFx.IO.IStream{JsonFx.Serialization.Token{`0}},`1@)">
            <summary>
            Allows a class to act as a factory for a type via input Token&lt;T&gt; sequence
            </summary>
            <param name="tokens">input tokens</param>
            <param name="value"></param>
            <returns>true if value was generated</returns>
        </member>
        <member name="M:JsonFx.Serialization.Filters.IDataFilter`2.TryWrite(JsonFx.Serialization.DataWriterSettings,`1,System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}}@)">
            <summary>
            Allows a class to serialize a type as Token&lt;T&gt; sequence
            </summary>
            <param name="value"></param>
            <param name="tokens"></param>
            <returns>true if value was consumed</returns>
        </member>
        <member name="T:JsonFx.Model.Filters.Iso8601DateFilter">
            <summary>
            Defines a filter for JSON-style serialization of DateTime into ISO-8601 string
            </summary>
            <remarks>
            This is the format used by EcmaScript 5th edition Date.prototype.toJSON(...):
            	http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf
            	http://www.w3.org/TR/NOTE-datetime
            	http://en.wikipedia.org/wiki/ISO_8601
            
            NOTE: This format limits expressing DateTime as either UTC or Unspecified. Local (i.e. Server Local) is converted to UTC.
            </remarks>
        </member>
        <member name="M:JsonFx.Model.Filters.Iso8601DateFilter.TryParseIso8601(System.String,System.DateTime@)">
            <summary>
            Converts a ISO-8601 string to the corresponding DateTime representation
            </summary>
            <param name="date">ISO-8601 conformant date</param>
            <param name="value">UTC or Unspecified DateTime</param>
            <returns>true if parsing was successful</returns>
        </member>
        <member name="M:JsonFx.Model.Filters.Iso8601DateFilter.FormatIso8601(System.DateTime)">
            <summary>
            Converts a DateTime to the corresponding ISO-8601 string representation
            </summary>
            <param name="value"></param>
            <returns>ISO-8601 conformant date</returns>
        </member>
        <member name="P:JsonFx.Model.Filters.Iso8601DateFilter.Format">
            <summary>
            Determines the precision of fractional seconds.
            Defaults to EcmaScript precision of milliseconds.
            </summary>
        </member>
        <member name="T:JsonFx.Model.Filters.Iso8601DateFilter.Precision">
            <summary>
            Defines the precision of fractional seconds in ISO-8601 dates
            </summary>
        </member>
        <member name="T:JsonFx.Model.Filters.MSAjaxDateFilter">
            <summary>
            Defines a filter for JSON-style serialization of DateTime into an ASP.NET Ajax Date string.
            </summary>
            <remarks>
            This is the format used by Microsoft ASP.NET Ajax:
            	http://weblogs.asp.net/bleroy/archive/2008/01/18/dates-and-json.aspx
            
            NOTE: This format is limited to expressing DateTime at the millisecond level as UTC only.
            The WCF extension of adding a timezone is ignored as this returns UTC dates only.
            </remarks>
        </member>
        <member name="M:JsonFx.Model.Filters.MSAjaxDateFilter.TryParseMSAjaxDate(System.String,System.DateTime@)">
            <summary>
            Converts an ASP.NET Ajax date string to the corresponding DateTime representation
            </summary>
            <param name="date">ASP.NET Ajax date string</param>
            <param name="value"></param>
            <returns>true if parsing was successful</returns>
        </member>
        <member name="M:JsonFx.Model.Filters.MSAjaxDateFilter.FormatMSAjaxDate(System.DateTime)">
            <summary>
            Converts a DateTime to the corresponding ASP.NET Ajax date string representation
            </summary>
            <param name="value"></param>
            <returns>ASP.NET Ajax date string</returns>
        </member>
        <member name="T:JsonFx.Model.ModelWriter">
            <summary>
            Provides base implementation for standard serializers
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.DataWriter`1">
            <summary>
            Provides base implementation of standard serializers
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.IDataWriter">
            <summary>
            A common interface for data serializers
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.IDataWriter.Write(System.Object,System.IO.TextWriter)">
            <summary>
            Serializes the data to the given output
            </summary>
            <param name="output">the output writer</param>
            <param name="data">the data to be serialized</param>
        </member>
        <member name="M:JsonFx.Serialization.IDataWriter.Write(System.Object)">
            <summary>
            Serializes the data to the given output
            </summary>
            <param name="data">the data to be serialized</param>
            <returns>the serialized data</returns>
        </member>
        <member name="P:JsonFx.Serialization.IDataWriter.ContentEncoding">
            <summary>
            Gets the content encoding for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.IDataWriter.ContentType">
            <summary>
            Gets the supported content types for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.IDataWriter.FileExtension">
            <summary>
            Gets the supported file extensions for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.IDataWriter.Settings">
            <summary>
            Gets the settings used for serialization
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataWriter`1.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataWriter`1.Write(System.Object,System.IO.TextWriter)">
            <summary>
            Serializes the data to the given output
            </summary>
            <param name="data">the data to be serialized</param>
            <param name="output">the output writer</param>
        </member>
        <member name="M:JsonFx.Serialization.DataWriter`1.Write(System.Object)">
            <summary>
            Serializes the data to the given output
            </summary>
            <param name="data">the data to be serialized</param>
            <returns>the serialized data</returns>
        </member>
        <member name="M:JsonFx.Serialization.DataWriter`1.GetWalker">
            <summary>
            Gets the walker for this DataWriter
            </summary>
            <param name="dataWriterSettings"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.DataWriter`1.GetFormatter">
            <summary>
            Gets the formatter for this DataWriter
            </summary>
            <param name="dataWriterSettings"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Serialization.DataWriter`1.ContentEncoding">
            <summary>
            Gets the content encoding for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriter`1.ContentType">
            <summary>
            Gets the supported content types for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriter`1.FileExtension">
            <summary>
            Gets the supported file extensions for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriter`1.Settings">
            <summary>
            Gets the settings used for serialization
            </summary>
        </member>
        <member name="M:JsonFx.Model.ModelWriter.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Model.ModelWriter.GetWalker">
            <summary>
            Gets a walker for JSON
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Model.ModelWriter.ContentEncoding">
            <summary>
            Gets the content encoding for the serialized data
            </summary>
        </member>
        <member name="T:JsonFx.EcmaScript.EcmaScriptIdentifier">
            <summary>
            Represents an ECMAScript identifier for serialization.
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.ITextFormattable`1">
            <summary>
            Designates a type as being able to format itself to raw text
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.ITextFormattable`1.Format(JsonFx.Serialization.ITextFormatter{`0},System.IO.TextWriter)">
            <summary>
            Writes custom format to the output using either tokens or text 
            </summary>
            <param name="formatter"></param>
            <param name="writer"></param>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.VerifyIdentifier(System.String,System.Boolean)">
            <summary>
            Verifies is a valid EcmaScript identifier
            </summary>
            <param name="ident">the identifier</param>
            <returns>identifier</returns>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.VerifyIdentifier(System.String,System.Boolean,System.Boolean)">
            <summary>
            Verifies is a valid EcmaScript identifier
            </summary>
            <param name="ident">the identifier</param>
            <returns>identifier</returns>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.IsValidIdentifier(System.String,System.Boolean)">
            <summary>
            Verifies is a valid EcmaScript variable expression
            </summary>
            <param name="ident">the identifier</param>
            <returns>identifier</returns>
            <remarks>
            http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
            
            IdentifierName =
            	IdentifierStart | IdentifierName IdentifierPart
            IdentifierStart =
            	Letter | '$' | '_'
            IdentifierPart =
            	IdentifierStart | Digit
            </remarks>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.Parse(System.String)">
            <summary>
            Trivial conversion method. Essentially performs a cast.
            </summary>
            <param name="value"></param>
            <returns></returns>
            <remarks>
            Supports conversion via System.Web.UI.PropertyConverter.ObjectFromString(Type, MemberInfo, string)
            </remarks>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.op_Implicit(JsonFx.EcmaScript.EcmaScriptIdentifier)~System.String">
            <summary>
            Implicit type conversion allows to be used directly as a String
            </summary>
            <param name="ident">valid ECMAScript identifier</param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.op_Implicit(System.String)~JsonFx.EcmaScript.EcmaScriptIdentifier">
            <summary>
            Implicit type conversion allows to be used directly with Strings
            </summary>
            <param name="ident">valid ECMAScript identifier</param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.ToString">
            <summary>
            Returns the identifier
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.Equals(System.Object)">
            <summary>
            Compares identifiers
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptIdentifier.GetHashCode">
            <summary>
            Returns the hash code for the identifier
            </summary>
            <returns></returns>
        </member>
        <member name="P:JsonFx.EcmaScript.EcmaScriptIdentifier.Identifier">
            <summary>
            Gets the ECMAScript identifier represented by this instance
            </summary>
        </member>
        <member name="T:JsonFx.EcmaScript.EcmaScriptFormatter">
            <summary>
            Formats data as full ECMAScript objects, rather than the limited set of JSON objects.
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonWriter.JsonFormatter">
            <summary>
            Outputs JSON text from an input stream of tokens
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.ITextFormatter`1">
            <summary>
            Outputs text from an input stream of JSON tokens
            </summary>
            <typeparam name="T">token type</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.ITextFormatter`1.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}},System.IO.TextWriter)">
            <summary>
            Formats the token sequence to the output writer
            </summary>
            <param name="tokens"></param>
            <param name="writer"></param>
        </member>
        <member name="M:JsonFx.Serialization.ITextFormatter`1.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}})">
            <summary>
            Formats the token sequence as a string
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="T:JsonFx.Json.JsonWriter">
            <summary>
            JSON serializer
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.#ctor(JsonFx.Serialization.DataWriterSettings,System.String[])">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
            <param name="contentTypes"></param>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.GetFormatter">
            <summary>
            Gets the formatter for JSON
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Json.JsonWriter.ContentType">
            <summary>
            Gets the supported content type for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Json.JsonWriter.FileExtension">
            <summary>
            Gets the supported file extension for the serialized data
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonWriter.JsonFormatter">
            <summary>
            Outputs JSON text from an input stream of tokens
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.JsonFormatter.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.JsonFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Formats the token sequence as a string
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.JsonFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},System.IO.TextWriter)">
            <summary>
            Formats the token sequence to the writer
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.JsonFormatter.FormatString(System.Object)">
            <summary>
            Converts an object to its string representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.JsonFormatter.FormatEnum(System.Enum)">
            <summary>
            Converts an enum to its string representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.JsonFormatter.GetFlagList(System.Type,System.Object)">
            <summary>
            Splits a bitwise-OR'd set of enums into a list.
            </summary>
            <param name="enumType">the enum type</param>
            <param name="value">the combined value</param>
            <returns>list of flag enums</returns>
            <remarks>
            from PseudoCode.EnumHelper
            </remarks>
        </member>
        <member name="M:JsonFx.Json.JsonWriter.JsonFormatter.InvalidIEEE754(System.Decimal)">
            <summary>
            Determines if a numeric value cannot be represented as IEEE-754.
            </summary>
            <param name="value"></param>
            <returns></returns>
            <remarks>
            http://stackoverflow.com/questions/1601646
            </remarks>
        </member>
        <member name="P:JsonFx.Json.JsonWriter.JsonFormatter.EncodeLessThan">
            <summary>
            Gets and sets if '&lt;' should be encoded in strings
            Useful for when emitting directly into page
            </summary>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptFormatter.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
            <remarks>
            Defaults to encoding &lt; chars for improved embedding within script blocks
            </remarks>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptFormatter.WriteNamespaceDeclaration(System.IO.TextWriter,System.String,System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Emits a block of script ensuring that a namespace is declared
            </summary>
            <param name="writer">the output writer</param>
            <param name="ident">the namespace to ensure</param>
            <param name="namespaces">list of namespaces already emitted</param>
            <param name="debug">determines if should emit pretty-printed</param>
            <returns>if was a namespaced identifier</returns>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptFormatter.WriteEcmaScriptRegExp(System.IO.TextWriter,System.Text.RegularExpressions.Regex)">
            <summary>
            Outputs a .NET Regex as an ECMAScript RegExp literal.
            Defaults to global matching off.
            </summary>
            <param name="writer"></param>
            <param name="regex"></param>
            <remarks>
            http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
            </remarks>
        </member>
        <member name="M:JsonFx.EcmaScript.EcmaScriptFormatter.WriteEcmaScriptRegExp(System.IO.TextWriter,System.Text.RegularExpressions.Regex,System.Boolean)">
            <summary>
            Outputs a .NET Regex as an ECMAScript RegExp literal.
            </summary>
            <param name="writer"></param>
            <param name="regex"></param>
            <param name="isGlobal"></param>
            <remarks>
            http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
            </remarks>
        </member>
        <member name="T:JsonFx.Html.IHtmlFilterStrategy">
            <summary>
            Defines a strategy for filtering HTML tags/attributes/styles/literals
            </summary>
        </member>
        <member name="M:JsonFx.Html.IHtmlFilterStrategy.FilterTag(JsonFx.Serialization.DataName,JsonFx.Markup.MarkupTokenType,JsonFx.Html.HtmlTaxonomy)">
            <summary>
            Filters tags, optionally allowing altering of tag
            </summary>
            <param name="tag">tag name</param>
            <returns>if true tag should be rendered</returns>
        </member>
        <member name="M:JsonFx.Html.IHtmlFilterStrategy.FilterAttribute(JsonFx.Serialization.DataName,JsonFx.Serialization.DataName,System.Object@)">
            <summary>
            Filters attributes, optionally allowing altering of attribute value
            </summary>
            <param name="tag">tag name</param>
            <param name="attribute">attribute name</param>
            <param name="value">attribute value</param>
            <returns>if true attribute should be rendered</returns>
        </member>
        <member name="M:JsonFx.Html.IHtmlFilterStrategy.FilterStyle(JsonFx.Serialization.DataName,System.String,System.Object@)">
            <summary>
            Filters styles, optionally allowing altering of style value
            </summary>
            <param name="tag">tag name</param>
            <param name="style">style name</param>
            <param name="value">style value</param>
            <returns>if true style should be rendered</returns>
        </member>
        <member name="M:JsonFx.Html.IHtmlFilterStrategy.FilterLiteral(System.Object@)">
            <summary>
            Filters literals, optionally allowing replacement of literal value
            </summary>
            <param name="value">the literal value</param>
            <returns>if true should be rendered</returns>
        </member>
        <member name="T:JsonFx.Html.HtmlFilter">
            <summary>
            Provides a mechanism for filtering HTML streams based upon a tag taxonomy
            </summary>
        </member>
        <member name="M:JsonFx.Html.HtmlFilter.VoidTagRequired(System.String)">
            <summary>
            Determines if is "void" (i.e. "empty" or "full") tag
            </summary>
            <param name="tag">lowercase tag name</param>
            <returns>if is a void tag</returns>
            <remarks>
            http://www.w3.org/TR/html5/semantics.html
            http://www.w3.org/TR/html401/index/elements.html
            http://www.w3.org/TR/xhtml-modularization/abstract_modules.html#sec_5.2.
            http://www.w3.org/TR/WD-html40-970917/index/elements.html
            </remarks>
        </member>
        <member name="M:JsonFx.Html.HtmlFilter.CloseTagOptional(System.String)">
            <summary>
            Determines if the tag is required to be closed
            </summary>
            <param name="tag">lowercase tag name</param>
            <returns>if closing tag is optional</returns>
            <remarks>
            http://www.w3.org/TR/html5/semantics.html
            http://www.w3.org/TR/html401/index/elements.html
            http://www.w3.org/TR/WD-html40-970917/index/elements.html
            </remarks>
        </member>
        <member name="M:JsonFx.Html.HtmlFilter.GetTaxonomy(System.String)">
            <summary>
            Categorizes the tag for heuristics about markup type
            </summary>
            <param name="tag">lowercase tag name</param>
            <returns>the box type for a particular element</returns>
            <remarks>
            http://www.w3.org/TR/html5/semantics.html
            </remarks>
        </member>
        <member name="T:JsonFx.Html.HtmlTaxonomy">
            <summary>
            Defines a prioritized taxonomy of tags
            </summary>
            <remarks>
            The types are enumerated in ascending levels of risk for use in filtering HTML input
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Text">
            <summary>
            Literal text, no tags
            </summary>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Inline">
            <summary>
            Inline character level elements and text strings
            </summary>
            <remarks>
            Tags of this type typically do not disrupt the text flow
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Style">
            <summary>
            style elements
            </summary>
            <remarks>
            Tags of this type change the visual appearance of text
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.List">
            <summary>
            list elements
            </summary>
            <remarks>
            Tags of this type denote lists and typically change the text flow
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Block">
            <summary>
            Block-level elements
            </summary>
            <remarks>
            Tags of this type denote sections or change the text flow
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Media">
            <summary>
            Media elements
            </summary>
            <remarks>
            Tags of this type safely embed media content
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Table">
            <summary>
            Tabular elements
            </summary>
            <remarks>
            Tags of this type have a very specific structure and their own rendering model
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Form">
            <summary>
            Form elements
            </summary>
            <remarks>
            Tags of this type are used in the construction of forms for capturing user input
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Script">
            <summary>
            Script elements
            </summary>
            <remarks>
            Tags of this type represent a security risk to the containing document but must obey the browser security sandbox
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Document">
            <summary>
            Document elements
            </summary>
            <remarks>
            Tags of this type are used to construct the document itself
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Plugin">
            <summary>
            embedded elements
            </summary>
            <remarks>
            Tags of this type represent a large security risk to the containing document as plug-ins may circumvent the browser security sandbox
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlTaxonomy.Unknown">
            <summary>
            Unknown elements
            </summary>
        </member>
        <member name="T:JsonFx.Html.HtmlFormatter">
            <summary>
            Outputs markup text from an input stream of tokens
            </summary>
        </member>
        <member name="M:JsonFx.Html.HtmlFormatter.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Html.HtmlFormatter.ResetScopeChain">
            <summary>
            Resets the internal stack of elements
            </summary>
        </member>
        <member name="M:JsonFx.Html.HtmlFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}})">
            <summary>
            Formats the token sequence as a string
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Html.HtmlFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}},System.IO.TextWriter)">
            <summary>
            Formats the token sequence to the writer
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Html.HtmlFormatter.WriteLocalName(System.IO.TextWriter,System.String)">
            <summary>
            Emits a valid XML local-name (i.e. encodes invalid chars including ':')
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <remarks>
            Explicitly escaping ':' to maintain compatibility with XML Namespaces.
            From XML 1.0, 5th ed. http://www.w3.org/TR/xml/#sec-common-syn
            	Name			= NameStartChar (NameChar)*
            	NameStartChar	= ":"
            					| [A-Z]
            					| "_"
            					| [a-z]
            					| [#xC0-#xD6]
            					| [#xD8-#xF6]
            					| [#xF8-#x2FF]
            					| [#x370-#x37D]
            					| [#x37F-#x1FFF]
            					| [#x200C-#x200D]
            					| [#x2070-#x218F]
            					| [#x2C00-#x2FEF]
            					| [#x3001-#xD7FF]
            					| [#xF900-#xFDCF]
            					| [#xFDF0-#xFFFD]
            					| [#x10000-#xEFFFF]
            	NameChar		= NameStartChar
            					| "-"
            					| "."
            					| [0-9]
            					| #xB7
            					| [#x0300-#x036F]
            					| [#x203F-#x2040]
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JsonFx.Html.HtmlFormatter.HtmlEncode(System.IO.TextWriter,System.String)" -->
        <member name="M:JsonFx.Html.HtmlFormatter.HtmlEncode(System.IO.TextWriter,System.String,System.Boolean)">
            <summary>
            Emits valid XML character data
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="encodeNonAscii">encodes all non-ASCII chars</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JsonFx.Html.HtmlFormatter.HtmlAttributeEncode(System.IO.TextWriter,System.String)" -->
        <member name="M:JsonFx.Html.HtmlFormatter.HtmlAttributeEncode(System.IO.TextWriter,System.String,System.Boolean)">
            <summary>
            Emits valid XML attribute character data
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
            <param name="encodeNonAscii">encodes all non-ASCII chars</param>
        </member>
        <member name="P:JsonFx.Html.HtmlFormatter.CanonicalForm">
            <summary>
            Gets and sets a value indicating if should emit canonical form
            </summary>
            <remarks>
            http://www.w3.org/TR/xml-c14n
            </remarks>
        </member>
        <member name="P:JsonFx.Html.HtmlFormatter.EmptyAttributes">
            <summary>
            Gets and sets a value indicating how should emit empty attributes
            </summary>
        </member>
        <member name="P:JsonFx.Html.HtmlFormatter.EncodeNonAscii">
            <summary>
            Gets and sets a value indicating if should encode text chars above the ASCII range
            </summary>
            <remarks>
            This option can help when the output is being embedded within an unknown encoding
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlFormatter.EmptyAttributeType.Html">
            <summary>
            HTML-style empty attributes do not emit a quoted string
            </summary>
            <remarks>
            http://www.w3.org/TR/html5/syntax.html#attributes-0
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlFormatter.EmptyAttributeType.Xhtml">
            <summary>
            XHTML-style empty attributes repeat the attribute name as its value
            </summary>
            <remarks>
            http://www.w3.org/TR/xhtml-media-types/#C_10
            http://www.w3.org/TR/xhtml1/#C_10
            http://www.w3.org/TR/html5/the-xhtml-syntax.html
            </remarks>
        </member>
        <member name="F:JsonFx.Html.HtmlFormatter.EmptyAttributeType.Xml">
            <summary>
            XML-style empty attributes emit an empty quoted string
            </summary>
            <remarks>
            http://www.w3.org/TR/xml/#sec-starttags
            </remarks>
        </member>
        <member name="T:JsonFx.Html.HtmlTokenizer">
            <summary>
            Generates a sequence of tokens from a generalized model of markup text (e.g. HTML, XML, JBST, ASPX/ASCX, ASP, JSP, PHP, etc.)
            </summary>
            <remarks>
            This generates a stream of tokens like StAX (Streaming API for XML)
            Unlike XML, this follows a more permissive markup format with automatic recovery most similar to HTML5.
            </remarks>
        </member>
        <member name="T:JsonFx.Serialization.ITextTokenizer`1">
            <summary>
            Generates a sequence of tokens from a sequence of characters
            </summary>
            <typeparam name="T">token type</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.ITextTokenizer`1.GetTokens(System.IO.TextReader)">
            <summary>
            Tokenizes the input sequence into tokens
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.ITextTokenizer`1.GetTokens(System.String)">
            <summary>
            Tokenizes the input sequence into tokens
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Serialization.ITextTokenizer`1.Column">
            <summary>
            Gets the current column of the underlying input character sequence
            </summary>
            <remarks>
            Tokenizers not tracking columns should return -1.
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.ITextTokenizer`1.Line">
            <summary>
            Gets the current line of the underlying input character sequence
            </summary>
            <remarks>
            Tokenizers not tracking lines should return -1.
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.ITextTokenizer`1.Index">
            <summary>
            Gets the current position of the underlying input character sequence
            </summary>
            <remarks>
            Tokenizers not tracking index should return -1.
            </remarks>
        </member>
        <member name="M:JsonFx.Html.HtmlTokenizer.DecodeEntity(JsonFx.IO.ITextStream)">
            <summary>
            Decodes HTML-style entities into special characters
            </summary>
            <param name="scanner"></param>
            <returns>the entity text</returns>
            <remarks>
            TODO: validate against HTML5-style entities
            http://www.w3.org/TR/html5/tokenization.html#consume-a-character-reference
            </remarks>
        </member>
        <member name="M:JsonFx.Html.HtmlTokenizer.DecodeEntityName(System.String)">
            <summary>
            Decodes most known named entities
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Html.HtmlTokenizer.IsNameStartChar(System.Char)">
            <summary>
            Checks for element start char
            </summary>
            <param name="ch"></param>
            <returns></returns>
            <remarks>
            http://www.w3.org/TR/xml/#sec-common-syn
            </remarks>
        </member>
        <member name="M:JsonFx.Html.HtmlTokenizer.IsNameChar(System.Char)">
            <summary>
            Checks for element name char
            </summary>
            <param name="ch"></param>
            <returns></returns>
            <remarks>
            http://www.w3.org/TR/xml/#sec-common-syn
            </remarks>
        </member>
        <member name="M:JsonFx.Html.HtmlTokenizer.GetTokens(System.IO.TextReader)">
            <summary>
            Gets a token sequence from the TextReader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Html.HtmlTokenizer.GetTokens(System.String)">
            <summary>
            Gets a token sequence from the string
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Html.HtmlTokenizer.AutoBalanceTags">
            <summary>
            Gets and sets if should attempt to auto-balance mismatched tags.
            </summary>
        </member>
        <member name="P:JsonFx.Html.HtmlTokenizer.UnwrapUnparsedComments">
            <summary>
            Gets and sets if should unwrap comments inside <see cref="P:JsonFx.Html.HtmlTokenizer.UnparsedTags"/>.
            </summary>
            <remarks>
            For example, in HTML this would include "script" and "style" tags.
            </remarks>
        </member>
        <member name="P:JsonFx.Html.HtmlTokenizer.UnparsedTags">
            <summary>
            Gets and sets a set of tags which should not have their content parsed.
            </summary>
            <remarks>
            For example, in HTML this would include "script" and "style" tags.
            </remarks>
        </member>
        <member name="P:JsonFx.Html.HtmlTokenizer.Column">
            <summary>
            Gets the total number of characters read from the input
            </summary>
        </member>
        <member name="P:JsonFx.Html.HtmlTokenizer.Line">
            <summary>
            Gets the total number of lines read from the input
            </summary>
        </member>
        <member name="P:JsonFx.Html.HtmlTokenizer.Index">
            <summary>
            Gets the current position within the input
            </summary>
        </member>
        <member name="M:JsonFx.Html.HtmlTokenizer.QName.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="T:JsonFx.Html.HtmlOutTransformer">
            <summary>
            Renders Common Model Tokens into a semantic HTML representation of the data structure
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.IDataTransformer`2">
            <summary>
            Consumes a sequence of tokens and produces a token sequence of a different type
            </summary>
            <typeparam name="TIn">input token type</typeparam>
            <typeparam name="TOut">output token type</typeparam>
        </member>
        <member name="M:JsonFx.Serialization.IDataTransformer`2.Transform(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{`0}})">
            <summary>
            Transforms the token sequence from <typeparamref name="TIn"/> to <typeparamref name="TOut"/>
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Html.HtmlOutTransformer.Transform(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Consumes a sequence of tokens and produces a token sequence of a different type
            </summary>
        </member>
        <member name="M:JsonFx.Html.HtmlOutTransformer.TransformValue(System.Collections.Generic.List{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}},JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Formats the token sequence to the output
            </summary>
            <param name="output"></param>
            <param name="input"></param>
        </member>
        <member name="T:JsonFx.IO.CharBuffer">
            <summary>
            StringBuilder-like implementation built like List&lt;char&gt;
            </summary>
        </member>
        <member name="M:JsonFx.IO.CharBuffer.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.IO.CharBuffer.#ctor(System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:JsonFx.IO.CharBuffer.Clear">
            <summary>
            Resets the buffer to an empty state
            </summary>
        </member>
        <member name="M:JsonFx.IO.CharBuffer.Append(System.Char)">
            <summary>
            Appends a single char to the buffer
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.CharBuffer.Append(System.String)">
            <summary>
            Appends a string value to the buffer
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.CharBuffer.CopyTo(System.Text.StringBuilder)">
            <summary>
            Copies the buffer value into a <see cref="T:System.Text.StringBuilder"/>
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:JsonFx.IO.CharBuffer.Length">
            <summary>
            Gets the number of characters in the buffer
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JsonFx.IO.SequenceBuffer`1" -->
        <member name="M:JsonFx.IO.SequenceBuffer`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Ctor
            </summary>
            <param name="sequence"></param>
        </member>
        <member name="M:JsonFx.IO.SequenceBuffer`1.Enumerator.#ctor(JsonFx.IO.SequenceBuffer{`0})">
            <summary>
            Ctor
            </summary>
            <param name="sequence"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JsonFx.IO.Subsequence`1" -->
        <member name="M:JsonFx.IO.Subsequence`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="sequence"></param>
        </member>
        <member name="M:JsonFx.IO.Subsequence`1.Enumerator.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="sequence"></param>
            <param name="start"></param>
            <param name="count"></param>
        </member>
        <member name="T:JsonFx.IO.EnumerableStream`1">
            <summary>
            Supports forward-only iteration over an input sequence of <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:JsonFx.IO.Stream`1">
            <summary>
            Supports forward-only iteration over an input sequence of <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:JsonFx.IO.IStream`1">
            <summary>
            Supports forward-only iteration over an input sequence
            </summary>
        </member>
        <member name="M:JsonFx.IO.IStream`1.Peek">
            <summary>
            Returns but does not remove the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.IStream`1.Pop">
            <summary>
            Returns and removes the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.IStream`1.BeginChunk">
            <summary>
            Begins chunking at the current index
            </summary>
        </member>
        <member name="M:JsonFx.IO.IStream`1.EndChunk">
            <summary>
            Ends chunking at the current index and returns the buffered sequence chunk
            </summary>
            <returns></returns>
        </member>
        <member name="P:JsonFx.IO.IStream`1.IsCompleted">
            <summary>
            Determines if the sequence has completed.
            </summary>
        </member>
        <member name="P:JsonFx.IO.IStream`1.IsChunking">
            <summary>
            Gets a value indicating if is currently capturing a sequence
            </summary>
        </member>
        <member name="P:JsonFx.IO.IStream`1.ChunkSize">
            <summary>
            Gets the number of items currently chunked
            </summary>
        </member>
        <member name="M:JsonFx.IO.Stream`1.Create(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Factory method for generic streams
            </summary>
            <param name="sequence"></param>
            <param name="buffered"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.Stream`1.Peek">
            <summary>
            Returns but does not remove the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.Stream`1.Pop">
            <summary>
            Returns and removes the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="P:JsonFx.IO.Stream`1.IsCompleted">
            <summary>
            Determines if the input sequence has reached the end
            </summary>
        </member>
        <member name="M:JsonFx.IO.EnumerableStream`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Ctor
            </summary>
            <param name="sequence"></param>
        </member>
        <member name="M:JsonFx.IO.EnumerableStream`1.Peek">
            <summary>
            Returns but does not remove the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.EnumerableStream`1.Pop">
            <summary>
            Returns and removes the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.EnumerableStream`1.EnsureReady">
            <summary>
            Deferred execution of iterator
            </summary>
        </member>
        <member name="P:JsonFx.IO.EnumerableStream`1.IsCompleted">
            <summary>
            Determines if the input sequence has reached the end
            </summary>
        </member>
        <member name="T:JsonFx.IO.ListStream`1">
            <summary>
            Supports a simple iteration over a list with ability to capture a subsequence
            </summary>
        </member>
        <member name="M:JsonFx.IO.ListStream`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Ctor
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JsonFx.IO.ListStream`1.BeginChunk">
            <summary>
            Begins chunking at the current index
            </summary>
        </member>
        <member name="M:JsonFx.IO.ListStream`1.EndChunk">
            <summary>
            Ends chunking at the current index and returns the buffered chunk
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.ListStream`1.Peek">
            <summary>
            Returns but does not remove the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.ListStream`1.Pop">
            <summary>
            Returns and removes the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.ListStream`1.EnsureReady">
            <summary>
            Deferred execution of iterator
            </summary>
        </member>
        <member name="P:JsonFx.IO.ListStream`1.ChunkSize">
            <summary>
            Gets the number of characters currently chunked
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:JsonFx.IO.ListStream`1.IsChunking" -->
        <member name="P:JsonFx.IO.ListStream`1.IsCompleted">
            <summary>
            Determines if the input sequence has reached the end
            </summary>
        </member>
        <member name="T:JsonFx.IO.ITextStream">
            <summary>
            Supports a simple iteration over a text input tracking line/column/position
            </summary>
        </member>
        <member name="M:JsonFx.IO.ITextStream.EndChunk">
            <summary>
            Ends chunking at the current index and returns the buffered text chunk
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.ITextStream.EndChunk(System.Text.StringBuilder)">
            <summary>
            Ends chunking at the current index and writes the buffered text chunk into the provided StringBuilder
            </summary>
            <returns></returns>
        </member>
        <member name="P:JsonFx.IO.ITextStream.Column">
            <summary>
            Gets the total number of characters read from the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.ITextStream.Line">
            <summary>
            Gets the total number of lines read from the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.ITextStream.Index">
            <summary>
            Gets the current position within the input
            </summary>
        </member>
        <member name="T:JsonFx.IO.StringStream">
            <summary>
            Supports a simple iteration over a string tracking line/column/position
            </summary>
        </member>
        <member name="M:JsonFx.IO.StringStream.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JsonFx.IO.StringStream.BeginChunk">
            <summary>
            Begins chunking at the current index
            </summary>
        </member>
        <member name="M:JsonFx.IO.StringStream.JsonFx#IO#IStream{System#Char}#EndChunk">
            <summary>
            Ends chunking at the current index and returns the buffered text chunk
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.StringStream.EndChunk">
            <summary>
            Ends chunking at the current index and returns the buffered text chunk
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.StringStream.EndChunk(System.Text.StringBuilder)">
            <summary>
            Ends chunking at the current index and returns the buffered text chunk
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.StringStream.Peek">
            <summary>
            Returns but does not remove the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.StringStream.Pop">
            <summary>
            Returns and removes the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.StringStream.EnsureReady">
            <summary>
            Deferred execution of iterator
            </summary>
        </member>
        <member name="M:JsonFx.IO.StringStream.UpdateStats">
            <summary>
            Calculates index, line, and column statistics
            </summary>
        </member>
        <member name="M:JsonFx.IO.StringStream.Dispose">
            <summary>
            Releases all resources used
            </summary>
        </member>
        <member name="P:JsonFx.IO.StringStream.Column">
            <summary>
            Gets the total number of characters read from the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.StringStream.Line">
            <summary>
            Gets the total number of lines read from the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.StringStream.Index">
            <summary>
            Gets the current position within the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.StringStream.ChunkSize">
            <summary>
            Gets the number of characters currently chunked
            </summary>
        </member>
        <member name="P:JsonFx.IO.StringStream.IsChunking">
            <summary>
            Gets a value indicating if the <see cref="T:JsonFx.IO.StringStream"/> is currently chunking
            </summary>
        </member>
        <member name="P:JsonFx.IO.StringStream.IsCompleted">
            <summary>
            Determines if the input sequence has reached the end
            </summary>
        </member>
        <member name="T:JsonFx.IO.TextReaderStream">
            <summary>
            Supports a simple iteration over a TextReader tracking line/column/position
            </summary>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.#ctor(System.IO.TextReader)">
            <summary>
            Ctor
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.BeginChunk">
            <summary>
            Begins chunking at the current index
            </summary>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.JsonFx#IO#IStream{System#Char}#EndChunk">
            <summary>
            Ends chunking at the current index and returns the buffered text chunk
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.EndChunk">
            <summary>
            Ends chunking at the current index and returns the buffered text chunk
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.EndChunk(System.Text.StringBuilder)">
            <summary>
            Ends chunking at the current index and returns the buffered text chunk
            </summary>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.Peek">
            <summary>
            Returns but does not remove the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.Pop">
            <summary>
            Returns and removes the item at the front of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.EnsureReady">
            <summary>
            Deferred execution of iterator
            </summary>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.UpdateStats(System.Char,System.Char)">
            <summary>
            Calculates index, line, and column statistics
            </summary>
            <param name="prev"></param>
            <param name="value"></param>
        </member>
        <member name="M:JsonFx.IO.TextReaderStream.Dispose">
            <summary>
            Releases all resources used by the underlying reader
            </summary>
        </member>
        <member name="P:JsonFx.IO.TextReaderStream.Column">
            <summary>
            Gets the total number of characters read from the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.TextReaderStream.Line">
            <summary>
            Gets the total number of lines read from the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.TextReaderStream.Index">
            <summary>
            Gets the current position within the input
            </summary>
        </member>
        <member name="P:JsonFx.IO.TextReaderStream.ChunkSize">
            <summary>
            Gets the number of characters currently chunked
            </summary>
        </member>
        <member name="P:JsonFx.IO.TextReaderStream.IsChunking">
            <summary>
            Gets a value indicating if the <see cref="T:JsonFx.IO.TextReaderStream"/> is currently chunking
            </summary>
        </member>
        <member name="P:JsonFx.IO.TextReaderStream.IsCompleted">
            <summary>
            Determines if the input sequence has reached the end
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonGrammar">
            <summary>
            Formal language of tokens and symbols for JSON
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonIgnoreAttribute">
            <summary>
            Designates a property or field to not be serialized.
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonNameAttribute">
            <summary>
            Specifies the naming to use for a property or field when serializing
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonNameAttribute.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonNameAttribute.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:JsonFx.Json.JsonNameAttribute.Name">
            <summary>
            Gets and sets the name to be used in serialization
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonReader">
            <summary>
            JSON deserializer
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonReader.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonReader.#ctor(JsonFx.Serialization.DataReaderSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Json.JsonReader.#ctor(JsonFx.Serialization.DataReaderSettings,System.String[])">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
            <param name="contentTypes"></param>
        </member>
        <member name="P:JsonFx.Json.JsonReader.ContentType">
            <summary>
            Gets the supported content type of the serialized data
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonReader.JsonTokenizer">
            <summary>
            Generates a sequence of tokens from JSON text
            </summary>
        </member>
        <member name="M:JsonFx.Json.JsonReader.JsonTokenizer.GetTokens(JsonFx.IO.ITextStream)">
            <summary>
            Gets a token sequence from the scanner stream
            </summary>
            <param name="scanner"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Json.JsonReader.JsonTokenizer.ScanIdentifier(JsonFx.IO.ITextStream)">
            <summary>
            Scans for the longest valid EcmaScript identifier
            </summary>
            <returns>identifier</returns>
            <remarks>
            http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
            
            IdentifierName =
            	IdentifierStart | IdentifierName IdentifierPart
            IdentifierStart =
            	Letter | '$' | '_'
            IdentifierPart =
            	IdentifierStart | Digit
            </remarks>
        </member>
        <member name="M:JsonFx.Json.JsonReader.JsonTokenizer.GetTokens(System.IO.TextReader)">
            <summary>
            Gets a token sequence from the TextReader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Json.JsonReader.JsonTokenizer.GetTokens(System.String)">
            <summary>
            Gets a token sequence from the string
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Json.JsonReader.JsonTokenizer.Column">
            <summary>
            Gets the total number of characters read from the input
            </summary>
        </member>
        <member name="P:JsonFx.Json.JsonReader.JsonTokenizer.Line">
            <summary>
            Gets the total number of lines read from the input
            </summary>
        </member>
        <member name="P:JsonFx.Json.JsonReader.JsonTokenizer.Index">
            <summary>
            Gets the current position within the input
            </summary>
        </member>
        <member name="F:JsonFx.Json.JsonReader.JsonTokenizer.NeedsValueDelim.Forbidden">
            <summary>
            It is an error for the next token to be a value delim
            </summary>
        </member>
        <member name="F:JsonFx.Json.JsonReader.JsonTokenizer.NeedsValueDelim.CurrentIsDelim">
            <summary>
            Forbidden but differentiates between empty array/object and just written
            </summary>
        </member>
        <member name="F:JsonFx.Json.JsonReader.JsonTokenizer.NeedsValueDelim.Required">
            <summary>
            It is an error for the next token to NOT be a value delim
            </summary>
        </member>
        <member name="T:JsonFx.Json.JsonSpecifiedPropertyAttribute">
            <summary>
            Specifies the name of the property which specifies if member should be serialized.
            </summary>
            <remarks>
            These properties can be marked private/protected/internal and it will still be recognized
            </remarks>
        </member>
        <member name="M:JsonFx.Json.JsonSpecifiedPropertyAttribute.#ctor">
            <summary>
            Ctor
            </summary>
            <param name="propertyName">the name of the property which controls serialization for this member</param>
        </member>
        <member name="M:JsonFx.Json.JsonSpecifiedPropertyAttribute.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="propertyName">the name of the property which controls serialization for this member</param>
        </member>
        <member name="P:JsonFx.Json.JsonSpecifiedPropertyAttribute.SpecifiedProperty">
            <summary>
            Gets and sets the name of the property which
            specifies if member should be serialized
            </summary>
        </member>
        <member name="T:JsonFx.JsonML.JsonMLReader.JsonMLInTransformer">
            <summary>
            Transforms markup tokens into Common Model tokens using the (lossless) JsonML model
            </summary>
            <remarks>
            JsonML Grammer: http://jsonml.org
            </remarks>
        </member>
        <member name="M:JsonFx.JsonML.JsonMLReader.JsonMLInTransformer.Transform(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}})">
            <summary>
            Consumes a sequence of tokens and produces a token sequence of a different type
            </summary>
        </member>
        <member name="P:JsonFx.JsonML.JsonMLReader.JsonMLInTransformer.Whitespace">
            <summary>
            Determines how whitespace should be handled
            </summary>
        </member>
        <member name="T:JsonFx.JsonML.JsonMLWriter.JsonMLOutTransformer">
            <summary>
            Transforms Common Model tokens into markup tokens using the (lossless) JsonML model
            </summary>
            <remarks>
            JsonML Grammer: http://jsonml.org
            </remarks>
        </member>
        <member name="M:JsonFx.JsonML.JsonMLWriter.JsonMLOutTransformer.Transform(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Consumes a sequence of tokens and produces a token sequence of a different type
            </summary>
        </member>
        <member name="T:JsonFx.Json.Resolvers.JsonResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter using JsonNameAttribute / JsonIgnoreAttribute / JsonPropertySpecifiedAttribute
            </summary>
            <remarks>
            This is the default strategy from JsonFx v1.0
            </remarks>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.PocoResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter using plain old CLR object (POCO) names
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.IResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter
            </summary>
            <remarks>
            Provides an extensibility point to control member naming and visibility at a very granular level.
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.IResolverStrategy.IsPropertyIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Gets a value indicating if the property is to be serialized.
            </summary>
            <param name="member"></param>
            <param name="isImmutableType"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.IResolverStrategy.IsFieldIgnored(System.Reflection.FieldInfo)">
            <summary>
            Gets a value indicating if the field is to be serialized.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.IResolverStrategy.GetValueIgnoredCallback(System.Reflection.MemberInfo)">
            <summary>
            Determines if the property or field should not be serialized.
            </summary>
            <param name="member"></param>
            <param name="target"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.IResolverStrategy.GetName(System.Reflection.MemberInfo)">
            <summary>
            Gets the serialized name for the member.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.IResolverStrategy.SortMembers(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Resolvers.MemberMap})">
            <summary>
            Allows a strategy to perform a custom sort order to outputted members
            </summary>
            <param name="members"></param>
            <returns></returns>
            <remarks>
            A common usage is to ensure that Attributes sort first
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.PocoResolverStrategy.IsPropertyIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Gets a value indicating if the property is to be serialized.
            </summary>
            <param name="member"></param>
            <param name="isImmutableType"></param>
            <returns></returns>
            <remarks>default implementation is must be read/write properties, or immutable</remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.PocoResolverStrategy.IsFieldIgnored(System.Reflection.FieldInfo)">
            <summary>
            Gets a value indicating if the field is to be serialized.
            </summary>
            <param name="member"></param>
            <returns></returns>
            <remarks>default implementation is must be public, non-readonly field</remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.PocoResolverStrategy.GetValueIgnoredCallback(System.Reflection.MemberInfo)">
            <summary>
            Gets a delegate which determines if the property or field should not be serialized based upon its value.
            </summary>
            <param name="member"></param>
            <returns>if has a value equivalent to the DefaultValueAttribute</returns>
            <remarks>
            This is useful when default values need not be serialized.
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.PocoResolverStrategy.GetName(System.Reflection.MemberInfo)">
            <summary>
            Gets the serialized name for the member.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.PocoResolverStrategy.SortMembers(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Resolvers.MemberMap})">
            <summary>
            Allows a strategy to perform a custom sort order to outputted members
            </summary>
            <param name="members"></param>
            <returns></returns>
            <remarks>
            A common usage is to ensure that Attributes sort first
            </remarks>
        </member>
        <member name="M:JsonFx.Json.Resolvers.JsonResolverStrategy.IsPropertyIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Gets a value indicating if the property is to be serialized.
            </summary>
            <param name="member"></param>
            <param name="isImmutableType"></param>
            <returns></returns>
            <remarks>default implementation is must be read/write properties, or immutable</remarks>
        </member>
        <member name="M:JsonFx.Json.Resolvers.JsonResolverStrategy.IsFieldIgnored(System.Reflection.FieldInfo)">
            <summary>
            Gets a value indicating if the field is to be serialized.
            </summary>
            <param name="member"></param>
            <returns></returns>
            <remarks>default implementation is must be public, non-readonly field</remarks>
        </member>
        <member name="M:JsonFx.Json.Resolvers.JsonResolverStrategy.GetValueIgnoredCallback(System.Reflection.MemberInfo)">
            <summary>
            Gets a delegate which determines if the property or field should not be serialized based upon its value.
            </summary>
            <param name="member"></param>
            <returns>if has a value equivalent to the DefaultValueAttribute</returns>
            <remarks>
            This is useful for excluding serialization of default values.
            </remarks>
        </member>
        <member name="M:JsonFx.Json.Resolvers.JsonResolverStrategy.GetName(System.Reflection.MemberInfo)">
            <summary>
            Gets the serialized name for the member.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Markup.WhitespaceType">
            <summary>
            Determines whitespace handling
            </summary>
        </member>
        <member name="F:JsonFx.Markup.WhitespaceType.None">
            <summary>
            Removes insignificant whitespace
            </summary>
        </member>
        <member name="F:JsonFx.Markup.WhitespaceType.Preserve">
            <summary>
            Keep all whitespace
            </summary>
        </member>
        <member name="F:JsonFx.Markup.WhitespaceType.Normalize">
            <summary>
            Condenses all whitespace to single spaces
            </summary>
        </member>
        <member name="T:JsonFx.Markup.UnparsedBlock">
            <summary>
            Designates a type as being able to format itself to raw JSON text.
            </summary>
        </member>
        <member name="M:JsonFx.Markup.UnparsedBlock.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Markup.UnparsedBlock.#ctor(System.String,System.String,System.String)">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="P:JsonFx.Markup.UnparsedBlock.Begin">
            <summary>
            Gets and sets the starting delimiter
            </summary>
        </member>
        <member name="P:JsonFx.Markup.UnparsedBlock.End">
            <summary>
            Gets and sets the ending delimiter
            </summary>
        </member>
        <member name="P:JsonFx.Markup.UnparsedBlock.Value">
            <summary>
            Gets and sets the context
            </summary>
        </member>
        <member name="T:JsonFx.Markup.MarkupGrammar">
            <summary>
            Formal language of tokens and symbols for markup
            </summary>
        </member>
        <member name="M:JsonFx.Markup.MarkupGrammar.TokenUnparsed(System.String,System.String,System.String)">
            <summary>
            Any of a number of unparsed tags which typically contain specialized processing instructions
            </summary>
            <remarks>
            The name of the token is the beginning and ending delimiters as a format string (not including the '&lt;' or '&gt;')
            Includes the following types:
            
            	"&lt;!--", "-->"	XML/HTML/SGML comment
            	"&lt;!", ">"		XML/SGML declaration (e.g. DOCTYPE or server-side includes)
            
            	"&lt;?=", "?>"		PHP expression
            	"&lt;?", "?>"		PHP code block /XML processing instruction (e.g. the XML declaration)
            
            	"&lt;%--", "--%>"	ASP/PSP/JSP-style code comment
            	"&lt;%@",  "%>"		ASP/PSP/JSP directive
            	"&lt;%=",  "%>"		ASP/PSP/JSP/JBST expression
            	"&lt;%!",  "%>"		JSP/JBST declaration
            	"&lt;%#",  "%>"		ASP.NET/JBST databind expression
            	"&lt;%$",  "%>"		ASP.NET/JBST extension
            	"&lt;%",   "%>"		ASP code block / JSP scriptlet / PSP code block
            </remarks>
        </member>
        <member name="T:JsonFx.Markup.MarkupTokenType">
            <summary>
            tokens
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Markup.MarkupTokenType.None" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Markup.MarkupTokenType.ElementBegin" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Markup.MarkupTokenType.ElementEnd" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Markup.MarkupTokenType.ElementVoid" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Markup.MarkupTokenType.Attribute" -->
        <!-- Badly formed XML comment ignored for member "F:JsonFx.Markup.MarkupTokenType.Primitive" -->
        <member name="T:JsonFx.Markup.PrefixScopeChain">
            <summary>
            Maintains scope chain for namespace prefix mappings
            </summary>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Push(JsonFx.Markup.PrefixScopeChain.Scope)">
            <summary>
            Adds a new scope to the chain
            </summary>
            <param name="scope"></param>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Peek">
            <summary>
            Gets the last scope off the chain
            </summary>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Pop">
            <summary>
            Gets and removes the last scope off the chain
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.GetNamespace(System.String,System.Boolean)">
            <summary>
            Finds the namespace URI for a given prefix within the curren scope chain
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.GetPrefix(System.String,System.Boolean)">
            <summary>
            Finds the prefix for a given namespace URI within the curren scope chain
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.ContainsTag(JsonFx.Serialization.DataName)">
            <summary>
            Checks if the matching begin tag exists on the stack
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Clear">
            <summary>
            Resets the internal state of the scope chain.
            </summary>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.EnsurePrefix(System.String,System.String)">
            <summary>
            Looks up the prefix for the given namespace
            </summary>
            <param name="preferredPrefix"></param>
            <param name="namespaceUri"></param>
            <returns>null if namespace is empty and no default prefix found</returns>
        </member>
        <member name="T:JsonFx.Markup.PrefixScopeChain.Scope">
            <summary>
            Represents a scope boundary within a prefix scope chain
            </summary>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Scope.ContainsPrefix(System.String)">
            <summary>
            Returns if this scope boundary contains a mapping for a particular prefix
            </summary>
            <param name="prefix"></param>
            <returns>if this scope boundary contains a mapping for a particular prefix</returns>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Scope.ContainsNamespace(System.String)">
            <summary>
            Returns if this scope boundary contains a mapping for a particular namespace
            </summary>
            <param name="prefix"></param>
            <returns>if this scope boundary contains a mapping for a particular namespace</returns>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Scope.TryGetNamespace(System.String,System.String@)">
            <summary>
            Returns if this scope boundary contains a mapping for a particular prefix
            setting the namespace URI if one was found.
            </summary>
            <param name="prefix"></param>
            <param name="namespaceUri">the resolved namespace URI</param>
            <returns>if this scope boundary contains a mapping for a particular prefix</returns>
        </member>
        <member name="M:JsonFx.Markup.PrefixScopeChain.Scope.TryGetPrefix(System.String,System.String@)">
            <summary>
            Returns if this scope boundary contains a mapping for a particular prefix
            setting the prefix if one was found.
            </summary>
            <param name="namespaceUri"></param>
            <param name="prefix">the resolved prefix</param>
            <returns>if this scope boundary contains a mapping for a particular prefix</returns>
        </member>
        <member name="P:JsonFx.Markup.PrefixScopeChain.Scope.TagName">
            <summary>
            Gets and sets the tagname associated with this scope boundary
            </summary>
        </member>
        <member name="P:JsonFx.Markup.PrefixScopeChain.Scope.Item(System.String)">
            <summary>
            Gets and sets mappings between prefix and namespace URIs
            </summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Serialization.Providers.DataProviderUtility">
            <summary>
            Provides lookup capabilities for providers
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Providers.DataProviderUtility.ParseHeaders(System.String,System.String)">
            <summary>
            Parses HTTP headers for Media-Types
            </summary>
            <param name="accept">HTTP Accept header</param>
            <param name="contentType">HTTP Content-Type header</param>
            <returns>sequence of Media-Types</returns>
            <remarks>
            http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.Providers.DataProviderUtility.ParseMediaType(System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.ConventionResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter using convention-based name mapping
            </summary>
            <remarks>
            Converts standard .NET PascalCase naming convention into the specified naming convention.
            http://msdn.microsoft.com/en-us/library/x2dbyw72.aspx
            http://msdn.microsoft.com/en-us/library/141e06ef.aspx
            http://msdn.microsoft.com/en-us/library/xzf533w0.aspx
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ConventionResolverStrategy.#ctor(JsonFx.Serialization.Resolvers.ConventionResolverStrategy.WordCasing)">
            <summary>
            Ctor
            </summary>
            <param name="casing"></param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ConventionResolverStrategy.#ctor(JsonFx.Serialization.Resolvers.ConventionResolverStrategy.WordCasing,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="casing"></param>
            <param name="wordSeparator"></param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ConventionResolverStrategy.GetName(System.Reflection.MemberInfo)">
            <summary>
            Gets the serialized name for the member.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ConventionResolverStrategy.SplitWords(System.String)">
            <summary>
            Splits a multi-word name assuming standard .NET PascalCase conventions.
            </summary>
            <param name="multiword"></param>
            <returns></returns>
            <remarks>
            http://msdn.microsoft.com/en-us/library/x2dbyw72.aspx
            http://msdn.microsoft.com/en-us/library/141e06ef.aspx
            http://msdn.microsoft.com/en-us/library/xzf533w0.aspx
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JsonFx.Serialization.TransformTokenizer`2" -->
        <member name="M:JsonFx.Serialization.TransformTokenizer`2.#ctor(JsonFx.Serialization.ITextTokenizer{`0},JsonFx.Serialization.IDataTransformer{`0,`1})">
            <summary>
            Ctor
            </summary>
            <param name="tokenizer"></param>
            <param name="transformer"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JsonFx.Serialization.TransformFormatter`2" -->
        <member name="M:JsonFx.Serialization.TransformFormatter`2.#ctor(JsonFx.Serialization.ITextFormatter{`1},JsonFx.Serialization.IDataTransformer{`0,`1})">
            <summary>
            Ctor
            </summary>
            <param name="formatter"></param>
            <param name="transformer"></param>
        </member>
        <member name="T:JsonFx.Serialization.DataName">
            <summary>
            Represents a property or document name, and a corresponding namespace URI (or empty string).
            Analogous to XML "expanded name": http://www.w3.org/TR/REC-xml-names/#dt-expname
            </summary>
            <remarks>
            Namespaces must be a URI, but local-name can be any non-null string.
            It is up to formatters to determine how to properly represent names which are invalid for the format.
            </remarks>
        </member>
        <member name="F:JsonFx.Serialization.DataName.LocalName">
            <summary>
            local-name
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.DataName.Prefix">
            <summary>
            alias for the namespace
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.DataName.NamespaceUri">
            <summary>
            namespace
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.DataName.IsAttribute">
            <summary>
            Determines if name should be treated like an attribute
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataName.#ctor(System.Type)">
            <summary>
            Ctor
            </summary>
            <param name="type">a CLR Type used to generate the local-name</param>
            <remarks>
            This constructor implicitly delcares the namespace to be empty.
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.DataName.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="localName">any string is a valid local-name</param>
            <remarks>
            This constructor implicitly delcares the namespace to be empty.
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.DataName.#ctor(System.String,System.String,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="localName">any string is a valid local-name</param>
            <param name="namespaceUri">an absolute URI string, or null</param>
            <exception cref="T:System.ArgumentNullException">thrown if <paramref name="localName"/> is null</exception>
            <exception cref="T:System.ArgumentNullException">thrown if <paramref name="namespaceUri"/> is an invalid absolute URI</exception>
            <remarks>
            The namespace field follows XML recommendation of absolute URIs.
            Relative URIs are officially deprecated for namespaces: http://www.w3.org/2000/09/xppa
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.DataName.#ctor(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Ctor
            </summary>
            <param name="localName">any string is a valid local-name</param>
            <param name="namespaceUri">an absolute URI string, or null</param>
            <param name="isAttribute">determines if name should be an attribute name</param>
            <exception cref="T:System.ArgumentNullException">thrown if <paramref name="localName"/> is null</exception>
            <exception cref="T:System.ArgumentNullException">thrown if <paramref name="namespaceUri"/> is an invalid absolute URI</exception>
            <remarks>
            The namespace field follows XML recommendation of absolute URIs.
            Relative URIs are officially deprecated for namespaces: http://www.w3.org/2000/09/xppa
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.DataName.GetTypeName(System.Type)">
            <summary>
            Gets the local-name for a Type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.DataName.ToPrefixedName">
            <summary>
            Gets the prefixed name or simply local-name if is not a fully qualified name
            </summary>
            <param name="addPrefixIfQualifiedAndEmpty">true to generate a prefix if the prefix is empty but not the namespace</param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.DataName.ToQualifiedName">
            <summary>
            Gets the namespaced name or simply local-name if is not a fully qualified name
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.DataName.CompareTo(JsonFx.Serialization.DataName)">
            <summary>
            Compares two <see cref="T:JsonFx.Serialization.DataName"/> values and returns an indication of their relative sort order.
            </summary>
            <param name="that"></param>
            <returns></returns>
            <remarks>
            Performs ordering according to XML Canonicalization document order http://www.w3.org/TR/xml-c14n#DocumentOrder
            "An element's namespace nodes are sorted lexicographically by local name (the default namespace node, if one exists, has no local name and is therefore lexicographically least)."
            "An element's attribute nodes are sorted lexicographically with namespace URI as the primary key and local name as the secondary key (an empty namespace URI is lexicographically least)."
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.DataName.IsEmpty">
            <summary>
            Determines if this is an empty DataName
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.GraphCycles.GraphCycleException">
            <summary>
            Indicates a graph cycle was detected during serialization
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.SerializationException">
            <summary>
            Indicates an error occurred during serialization
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.SerializationException.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.SerializationException.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:JsonFx.Serialization.SerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.GraphCycleException.#ctor(JsonFx.Serialization.GraphCycles.GraphCycleType)">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.GraphCycleException.#ctor(JsonFx.Serialization.GraphCycles.GraphCycleType,System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.GraphCycleException.#ctor(JsonFx.Serialization.GraphCycles.GraphCycleType,System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="P:JsonFx.Serialization.GraphCycles.GraphCycleException.CycleType">
            <summary>
            Gets the type of cycle which caused the error
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.GraphCycles.GraphCycleType.Ignore">
            <summary>
            Graph cycles are detected with a reference tracking, any repeated reference results in a null value
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.GraphCycles.GraphCycleType.Reference">
            <summary>
            Graph cycles are detected with a reference tracking, any repeated reference results in an error
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.GraphCycles.GraphCycleType.MaxDepth">
            <summary>
            Graph cycles are detected with a maximum depth count, exceeding depth results in an error
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.GraphCycles.DepthCounter">
            <summary>
            Detects graph cycles by tracking graph depth
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.GraphCycles.ICycleDetector">
            <summary>
            Defines an interface for detecting graph cycles
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.ICycleDetector.Add(System.Object)">
            <summary>
            Begins tracking of the reference
            </summary>
            <param name="item"></param>
            <returns>true if graph cycle was detected</returns>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.ICycleDetector.Remove(System.Object)">
            <summary>
            Ends tracking of the reference
            </summary>
            <param name="item"></param>
            <returns>true if tracking was successfully completed</returns>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.DepthCounter.#ctor(System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="maxDepth"></param>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.DepthCounter.Add(System.Object)">
            <summary>
            Increments the depth
            </summary>
            <param name="item"></param>
            <returns>true if MaxDepth has not been exceeded</returns>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.DepthCounter.Remove(System.Object)">
            <summary>
            Increments the depth
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:JsonFx.Serialization.GraphCycles.ReferenceSet">
            <summary>
            Detects cycles by detecting duplicates in the a set of object references
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.ReferenceSet.Add(System.Object)">
            <summary>
            Adds a reference to the set
            </summary>
            <param name="item"></param>
            <returns>true if object already existed within set</returns>
        </member>
        <member name="M:JsonFx.Serialization.GraphCycles.ReferenceSet.Remove(System.Object)">
            <summary>
            Removes a reference from the set
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:JsonFx.Serialization.DataReaderSettings">
            <summary>
            Controls deserialization settings for IDataReader
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataReaderSettings.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataReaderSettings.#ctor(JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}[])">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataReaderSettings.#ctor(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}})">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataReaderSettings.#ctor(JsonFx.Serialization.Resolvers.IResolverStrategy,JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}[])">
            <summary>
            Ctor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataReaderSettings.#ctor(JsonFx.Serialization.Resolvers.IResolverStrategy,System.Collections.Generic.IEnumerable{JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}})">
            <summary>
            Ctor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataReaderSettings.#ctor(JsonFx.Serialization.Resolvers.ResolverCache,JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}[])">
            <summary>
            Ctor
            </summary>
            <param name="resolverCache"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataReaderSettings.#ctor(JsonFx.Serialization.Resolvers.ResolverCache,System.Collections.Generic.IEnumerable{JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}})">
            <summary>
            Ctor
            </summary>
            <param name="resolverCache"></param>
        </member>
        <member name="P:JsonFx.Serialization.DataReaderSettings.AllowNullValueTypes">
            <summary>
            Gets and sets if ValueTypes can accept values of null
            </summary>
            <remarks>
            If this is true and a ValueType T is assigned the value of null,
            it will receive the value of default(T).
            Setting this to false, throws an exception if null is
            specified for a ValueType member.
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.DataReaderSettings.AllowTrailingContent">
            <summary>
            Gets and sets if should verify that stream is empty after deserialzing each object
            </summary>
            <remarks>
            Setting to true allows reading a JSON stream inside other structures (e.g. JavaScript)
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.DataReaderSettings.Resolver">
            <summary>
            Gets manager of name resolution for IDataReader
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataReaderSettings.Filters">
            <summary>
            Gets the custom filters
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.DataWriterSettings">
            <summary>
            Controls the serialization settings for IDataWriter
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataWriterSettings.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataWriterSettings.#ctor(JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}[])">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataWriterSettings.#ctor(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}})">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DataWriterSettings.#ctor(JsonFx.Serialization.Resolvers.IResolverStrategy,JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}[])">
            <summary>
            Ctor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataWriterSettings.#ctor(JsonFx.Serialization.Resolvers.IResolverStrategy,System.Collections.Generic.IEnumerable{JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}})">
            <summary>
            Ctor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataWriterSettings.#ctor(JsonFx.Serialization.Resolvers.ResolverCache,JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}[])">
            <summary>
            Ctor
            </summary>
            <param name="resolverCache"></param>
        </member>
        <member name="M:JsonFx.Serialization.DataWriterSettings.#ctor(JsonFx.Serialization.Resolvers.ResolverCache,System.Collections.Generic.IEnumerable{JsonFx.Serialization.Filters.IDataFilter{JsonFx.Model.ModelTokenType}})">
            <summary>
            Ctor
            </summary>
            <param name="resolverCache"></param>
        </member>
        <member name="P:JsonFx.Serialization.DataWriterSettings.GraphCycles">
            <summary>
            Gets and sets what to do when graph cycles (repeated references) are encounted
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriterSettings.MaxDepth">
            <summary>
            Gets and sets the maximum nesting depth
            </summary>
            <remarks>
            Depth is a fast and easy safegaurd against detecting graph cycles but may produce false positives
            </remarks>
        </member>
        <member name="P:JsonFx.Serialization.DataWriterSettings.PrettyPrint">
            <summary>
            Gets and sets if output will be formatted for human reading.
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriterSettings.Tab">
            <summary>
            Gets and sets the string to use for indentation
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriterSettings.NewLine">
            <summary>
            Gets and sets the line terminator string
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriterSettings.Resolver">
            <summary>
            Gets manager of name resolution for IDataReader
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DataWriterSettings.Filters">
            <summary>
            Gets the custom filters
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.DeserializationException">
            <summary>
            Indicates an error occurred during deserialization
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.DeserializationException.#ctor(System.String,System.Int64)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="index"></param>
        </member>
        <member name="M:JsonFx.Serialization.DeserializationException.#ctor(System.String,System.Int64,System.Int32,System.Int32)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="index"></param>
            <param name="line"></param>
            <param name="column"></param>
        </member>
        <member name="M:JsonFx.Serialization.DeserializationException.#ctor(System.String,System.Int64,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="index"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:JsonFx.Serialization.DeserializationException.#ctor(System.String,System.Int64,System.Int32,System.Int32,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="index"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:JsonFx.Serialization.DeserializationException.GetLineAndColumn(System.String,System.Int32@,System.Int32@)">
            <summary>
            Helper method which converts the index into Line and Column numbers
            </summary>
            <param name="source"></param>
            <param name="line"></param>
            <param name="col"></param>
        </member>
        <member name="P:JsonFx.Serialization.DeserializationException.Column">
            <summary>
            Gets the character column in the stream where the error occurred
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DeserializationException.Index">
            <summary>
            Gets the character position in the stream where the error occurred
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.DeserializationException.Line">
            <summary>
            Gets the character line in the stream where the error occurred
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.TokenException`1">
            <summary>
            Indicates an error occurred during token consumption
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JsonFx.Serialization.TokenException`1.#ctor(JsonFx.Serialization.Token{`0})">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.TokenException`1.#ctor(JsonFx.Serialization.Token{`0},System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:JsonFx.Serialization.TokenException`1.#ctor(JsonFx.Serialization.Token{`0},System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="P:JsonFx.Serialization.TokenException`1.Token">
            <summary>
            Gets the token in the sequence where the error occurred
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.TypeCoercionException">
            <summary>
            Indicates an error occurred during type coercion
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionException.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionException.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionException.#ctor(System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:JsonFx.Serialization.Providers.DataReaderProvider">
            <summary>
            Provides lookup capabilities for finding matching IDataReader
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.Providers.IDataReaderProvider">
            <summary>
            Provides lookup capabilities for finding matching IDataReader
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Providers.DataReaderProvider.#ctor(System.Collections.Generic.IEnumerable{JsonFx.Serialization.IDataReader})">
            <summary>
            Ctor
            </summary>
            <param name="readers">inject with all possible readers</param>
        </member>
        <member name="M:JsonFx.Serialization.Providers.DataReaderProvider.Find(System.String)">
            <summary>
            Finds an IDataReader by content-type header
            </summary>
            <param name="contentTypeHeader"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Serialization.Providers.DataWriterProvider">
            <summary>
            Provides lookup capabilities for finding an IDataWriter
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.Providers.IDataWriterProvider">
            <summary>
            Provides lookup capabilities for finding an IDataWriter
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Providers.DataWriterProvider.#ctor(System.Collections.Generic.IEnumerable{JsonFx.Serialization.IDataWriter})">
            <summary>
            Ctor
            </summary>
            <param name="writers">inject with all possible writers</param>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.CallbackResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter by using pluggable delegate callbacks
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.Resolvers.CallbackResolverStrategy.IsPropertyIgnored">
            <summary>
            Gets and sets the implementation for ignoring properties
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.Resolvers.CallbackResolverStrategy.IsFieldIgnored">
            <summary>
            Gets and sets the implementation for ignoring fields
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.Resolvers.CallbackResolverStrategy.GetValueIgnored">
            <summary>
            Gets and sets the implementation for ignoring properties by value
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.Resolvers.CallbackResolverStrategy.GetName">
            <summary>
            Gets and sets the implementation for naming members
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.Resolvers.CallbackResolverStrategy.SortMembers">
            <summary>
            Gets and sets the implementation for sorting members
            </summary>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.CombinedResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter by combining an ordered sequence of any other strategies
            </summary>
            <remarks>
            Each strategy is invoked in order, the first to respond wins.
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.CombinedResolverStrategy.#ctor(JsonFx.Serialization.Resolvers.IResolverStrategy[])">
            <summary>
            Ctor
            </summary>
            <param name="strategies">ordered sequence of strategies</param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.CombinedResolverStrategy.#ctor(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Resolvers.IResolverStrategy})">
            <summary>
            Ctor
            </summary>
            <param name="strategies">ordered sequence of strategies</param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.CombinedResolverStrategy.IsPropertyIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Gets a value indicating if the property is to be serialized.
            </summary>
            <param name="member"></param>
            <param name="isImmutableType"></param>
            <returns>true if any strategy specifies should be ignored</returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.CombinedResolverStrategy.IsFieldIgnored(System.Reflection.FieldInfo)">
            <summary>
            Gets a value indicating if the field is to be serialized.
            </summary>
            <param name="member"></param>
            <returns>true if any strategy specifies should be ignored</returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.CombinedResolverStrategy.GetValueIgnoredCallback(System.Reflection.MemberInfo)">
            <summary>
            Gets a delegate which determines if the property or field should not be serialized based upon its value.
            </summary>
            <param name="member"></param>
            <returns>true if any strategy specifies this should be ignored</returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.CombinedResolverStrategy.GetName(System.Reflection.MemberInfo)">
            <summary>
            Gets the serialized name for the member.
            </summary>
            <param name="member"></param>
            <returns></returns>
            <returns>custom name if any strategy specifies one, otherwise null</returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.CombinedResolverStrategy.SortMembers(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Resolvers.MemberMap})">
            <summary>
            Allows a strategy to perform a custom sort order to outputted members
            </summary>
            <param name="members"></param>
            <returns></returns>
            <remarks>
            A common usage is to ensure that Attributes sort first
            </remarks>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.DataContractResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter using DataContract attributes
            </summary>
            <remarks>
            http://msdn.microsoft.com/en-us/library/kd1dc9w5.aspx
            </remarks>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.DataContractResolverStrategy.#cctor">
            <summary>
            CCtor
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.DataContractResolverStrategy.IsPropertyIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Gets a value indicating if the property is to be serialized.
            </summary>
            <param name="member"></param>
            <param name="isImmutableType"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.DataContractResolverStrategy.IsFieldIgnored(System.Reflection.FieldInfo)">
            <summary>
            Gets a value indicating if the field is to be serialized.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.DataContractResolverStrategy.GetValueIgnoredCallback(System.Reflection.MemberInfo)">
            <summary>
            Gets a delegate which determines if the property or field should not be serialized based upon its value.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.DataContractResolverStrategy.GetName(System.Reflection.MemberInfo)">
            <summary>
            Gets the serialized name for the member.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.ValueIgnoredDelegate">
            <summary>
            Gets a delegate which determines if the property or field should not be serialized based upon its value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.MemberInfo">
            <summary>
            The original member info
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.Name">
            <summary>
            The original member name
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.DataName">
            <summary>
            The member data name
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.Type">
            <summary>
            The member type
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.Getter">
            <summary>
            The getter method
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.Setter">
            <summary>
            The setter method
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.IsIgnored">
            <summary>
            The logic for determining if a value is ignored
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Resolvers.MemberMap.IsAlternate">
            <summary>
            Determines if map name is alternate (i.e. only used for deserialization)
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.MemberMap.#ctor(JsonFx.Serialization.Resolvers.MemberMap,JsonFx.Serialization.DataName)">
            <summary>
            Ctor
            </summary>
            <param name="map">MemberMap to clone</param>
            <param name="dataName">alternate name</param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.MemberMap.#ctor(System.Reflection.PropertyInfo,JsonFx.Serialization.DataName,JsonFx.Serialization.Resolvers.ValueIgnoredDelegate)">
            <summary>
            Ctor
            </summary>
            <param name="propertyInfo"></param>
            <param name="dataName"></param>
            <param name="isIgnored"></param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.MemberMap.#ctor(System.Reflection.FieldInfo,JsonFx.Serialization.DataName,JsonFx.Serialization.Resolvers.ValueIgnoredDelegate)">
            <summary>
            Ctor
            </summary>
            <param name="fieldInfo"></param>
            <param name="dataName"></param>
            <param name="isIgnored"></param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.FactoryMap.#ctor(System.Type)">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.Resolvers.FactoryMap.ArgTypes">
            <summary>
            Gets a sequence of the available factory arguments
            </summary>
        </member>
        <member name="P:JsonFx.Serialization.Resolvers.FactoryMap.Item(System.Type)">
            <summary>
            Gets the factory associated with the given argument type
            </summary>
            <param name="argType"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Serialization.Resolvers.ResolverCache">
            <summary>
            Cache of name resolution mappings for IDataReader / IDataWriter
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ResolverCache.#ctor(JsonFx.Serialization.Resolvers.IResolverStrategy)">
            <summary>
            Ctor
            </summary>
            <param name="strategy"></param>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ResolverCache.LoadTypeName(System.Type)">
            <summary>
            Gets the serialized name of the class
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ResolverCache.Clear">
            <summary>
            Removes any cached member mappings.
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Resolvers.ResolverCache.BuildMap(System.Type,System.Collections.Generic.IDictionary{System.String,JsonFx.Serialization.Resolvers.MemberMap}@)">
            <summary>
            Builds a mapping of member name to field/property
            </summary>
            <param name="objectType"></param>
        </member>
        <member name="T:JsonFx.Serialization.Token`1">
            <summary>
            Represents a single immutable token in an input sequence
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Token`1.TokenType">
            <summary>
            The type of the token
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Token`1.Name">
            <summary>
            The name of the token
            </summary>
        </member>
        <member name="F:JsonFx.Serialization.Token`1.Value">
            <summary>
            The value of the token
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.#ctor(`0)">
            <summary>
            Ctor
            </summary>
            <param name="tokenType"></param>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.#ctor(`0,System.Object)">
            <summary>
            Ctor
            </summary>
            <param name="tokenType"></param>
            <param name="value"></param>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.#ctor(`0,JsonFx.Serialization.DataName)">
            <summary>
            Ctor
            </summary>
            <param name="tokenType"></param>
            <param name="name"></param>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.#ctor(`0,JsonFx.Serialization.DataName,System.Object)">
            <summary>
            Ctor
            </summary>
            <param name="tokenType"></param>
            <param name="name"></param>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.ToString">
            <summary>
            Returns a string that represents the current token.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.ValueAsString">
            <summary>
            Gets the value of the token as a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.ToString(System.Object)">
            <summary>
            Converts a value to a string giving opportunity for IConvertible, IFormattable
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.Token`1.ChangeType``1(``0)">
            <summary>
            Converts token to a token of a different type
            </summary>
            <typeparam name="TOther"></typeparam>
            <returns>token with same values and different type</returns>
        </member>
        <member name="T:JsonFx.Serialization.TypeCoercionUtility">
            <summary>
            Type Coercion Utility
            </summary>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.#ctor(JsonFx.Serialization.Resolvers.IResolverCacheContainer,System.Boolean)">
            <summary>
            Ctor
            </summary>
            <param name="cacheContainer"></param>
            <param name="allowNullValueTypes"></param>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.#ctor(JsonFx.Serialization.Resolvers.ResolverCache,System.Boolean)">
            <summary>
            Ctor
            </summary>
            <param name="resolverCache"></param>
            <param name="allowNullValueTypes"></param>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.InstantiateObjectDefaultCtor(System.Type)">
            <summary>
            Instantiates a new instance of objectType.
            </summary>
            <param name="objectType"></param>
            <returns>objectType instance</returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.InstantiateObject(System.Type,System.Object)">
            <summary>
            Instantiates a new instance of objectType.
            </summary>
            <param name="objectType"></param>
            <returns>objectType instance</returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.SetMemberValue(System.Object,System.Type,JsonFx.Serialization.Resolvers.MemberMap,System.String,System.Object)">
            <summary>
            Helper method to set value of a member.
            </summary>
            <param name="target"></param>
            <param name="targetType"></param>
            <param name="memberMap"></param>
            <param name="memberName"></param>
            <param name="memberValue"></param>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.CoerceType``1(System.Object)">
            <summary>
            Coerces the object value to Type <typeparamref name="T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.CoerceType(System.Type,System.Object)">
            <summary>
            Coerces the object value to Type of <paramref name="targetType"/>
            </summary>
            <param name="targetType"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.CoerceType(System.Type,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Populates the properties of an object with the dictionary values.
            </summary>
            <param name="targetType"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.CoerceType(System.Type,System.Collections.IDictionary)">
            <summary>
            Populates the properties of an object with the dictionary values.
            </summary>
            <param name="targetType"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.CoerceArray(System.Type,System.Collections.IEnumerable)">
            <summary>
            Coerces an sequence of items into an array of Type elementType
            </summary>
            <param name="elementType"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.ResolveInterfaceType(System.Type)">
            <summary>
            Finds a suitable concrete class for common collection interface types
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.GetDictionaryItemType(System.Type)">
            <summary>
            Allows specific IDictionary&lt;string, TVal&gt; to deserialize as TVal
            </summary>
            <param name="targetType">IDictionary&lt;string, TVal&gt; Type</param>
            <returns>TVal Type</returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.FindCommonType(System.Type,System.Object)">
            <summary>
            Returns a common type which can hold previous values and the new value
            </summary>
            <param name="itemType"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.IsNullable(System.Type)">
            <summary>
            Determines if type can be assigned a null value.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.HasAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attribute T for the given value.
            </summary>
            <param name="value"></param>
            <typeparam name="T">Attribute Type</typeparam>
            <returns>true if defined</returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.HasAttribute(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Gets the attribute of Type <param name="type" /> for the given value.
            </summary>
            <param name="value"></param>
            <returns>true if defined</returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.GetAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the attribute T for the given value.
            </summary>
            <param name="value"></param>
            <typeparam name="T">Attribute Type</typeparam>
            <returns>requested attribute or not if not defined</returns>
        </member>
        <member name="M:JsonFx.Serialization.TypeCoercionUtility.GetAttribute(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Gets the attribute of Type <param name="type" /> for the given value.
            </summary>
            <param name="value"></param>
            <returns>requested attribute or not if not defined</returns>
        </member>
        <member name="T:JsonFx.Utils.CharUtility">
            <summary>
            Character Utility
            </summary>
            <remarks>
            These are either simpler definitions of character classes (e.g. letter is [a-zA-Z]),
            or they implement platform-agnositic checks (read: "Silverlight workarounds").
            </remarks>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.IsNullOrWhiteSpace(System.String)">
            <summary>
            Checks if string is null, empty or entirely made up of whitespace
            </summary>
            <param name="value"></param>
            <returns></returns>
            <remarks>
            Essentially the same as String.IsNullOrWhiteSpace from .NET 4.0
            with a simplfied view of whitespace.
            </remarks>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.IsWhiteSpace(System.Char)">
            <summary>
            Checks if character is line ending, tab or space
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.IsControl(System.Char)">
            <summary>
            
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.IsLetter(System.Char)">
            <summary>
            Checks if character matches [A-Za-z]
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.IsDigit(System.Char)">
            <summary>
            Checks if character matches [0-9]
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.IsHexDigit(System.Char)">
            <summary>
            Checks if character matches [0-9A-Fa-f]
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.GetHexDigit(System.Int32)">
            <summary>
            Gets a 4-bit number as a hex digit
            </summary>
            <param name="i">0-15</param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.GetHexString(System.UInt64)">
            <summary>
            Formats a number as a hex digit
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.ConvertToUtf32(System.String,System.Int32)">
            <summary>
            Converts the value of a UTF-16 encoded character or surrogate pair at a specified
            position in a string into a Unicode code point.
            </summary>
            <param name="value"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Utils.CharUtility.ConvertFromUtf32(System.Int32)">
            <summary>
            Converts the specified Unicode code point into a UTF-16 encoded string.
            </summary>
            <param name="utf32"></param>
            <returns></returns>
        </member>
        <member name="T:JsonFx.Xml.XmlReader">
            <summary>
            XML serializer
            </summary>
            <summary>
            XML serializer
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.#ctor(JsonFx.Serialization.DataReaderSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.#ctor(JsonFx.Serialization.DataReaderSettings,System.String[])">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
            <param name="contentTypes"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.GetTokenizer">
            <summary>
            Gets a tokenizer for XML
            </summary>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Xml.XmlReader.ContentType">
            <summary>
            Gets the supported content type for the serialized data
            </summary>
        </member>
        <member name="T:JsonFx.Xml.XmlReader.XmlInTransformer">
            <summary>
            Transforms markup tokens into Common Model tokens using an XML-data model
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.XmlInTransformer.#ctor(JsonFx.Serialization.DataReaderSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.XmlInTransformer.Transform(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}})">
            <summary>
            Consumes a sequence of tokens and produces a token sequence of a different type
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.XmlInTransformer.TransformValue(JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}},System.Boolean)">
            <summary>
            Formats the token sequence to the output
            </summary>
            <param name="output"></param>
            <param name="input"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JsonFx.Xml.XmlReader.XmlTokenizer" -->
        <member name="M:JsonFx.Xml.XmlReader.XmlTokenizer.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.XmlTokenizer.#ctor(System.Xml.XmlReaderSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.XmlTokenizer.GetTokens(System.String)">
            <summary>
            Gets a token sequence from the string
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.XmlTokenizer.GetTokens(System.IO.TextReader)">
            <summary>
            Gets a token sequence from the TextReader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Xml.XmlReader.XmlTokenizer.GetTokens(System.Xml.XmlReader)">
            <summary>
            Gets a token sequence from the XmlReader
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Xml.XmlReader.XmlTokenizer.Column">
            <summary>
            Gets the total number of characters read from the input
            </summary>
        </member>
        <member name="P:JsonFx.Xml.XmlReader.XmlTokenizer.Line">
            <summary>
            Gets the total number of lines read from the input
            </summary>
        </member>
        <member name="P:JsonFx.Xml.XmlReader.XmlTokenizer.Index">
            <summary>
            Gets the current position within the input
            </summary>
        </member>
        <member name="T:JsonFx.Xml.XmlWriter">
            <summary>
            XML serializer
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.#ctor(JsonFx.Serialization.DataWriterSettings,System.String[])">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
            <param name="contentTypes"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.GetFormatter">
            <summary>
            Gets the formatter for XML
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="P:JsonFx.Xml.XmlWriter.ContentType">
            <summary>
            Gets the supported content type for the serialized data
            </summary>
        </member>
        <member name="P:JsonFx.Xml.XmlWriter.FileExtension">
            <summary>
            Gets the supported file extension for the serialized data
            </summary>
        </member>
        <member name="T:JsonFx.Xml.XmlWriter.XmlOutTransformer">
            <summary>
            Transforms Common Model tokens into markup tokens using an XML-data model
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlOutTransformer.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlOutTransformer.Transform(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}})">
            <summary>
            Consumes a sequence of tokens and produces a token sequence of a different type
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlOutTransformer.TransformValue(System.Collections.Generic.List{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}},JsonFx.IO.IStream{JsonFx.Serialization.Token{JsonFx.Model.ModelTokenType}},JsonFx.Serialization.DataName)">
            <summary>
            Formats the token sequence to the output
            </summary>
            <param name="output"></param>
            <param name="input"></param>
        </member>
        <member name="T:JsonFx.Xml.XmlWriter.XmlFormatter">
            <summary>
            Outputs XML text from an input stream of tokens
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlFormatter.#ctor(JsonFx.Serialization.DataWriterSettings)">
            <summary>
            Ctor
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}})">
            <summary>
            Formats the token sequence as a string
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlFormatter.Format(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}},System.IO.TextWriter)">
            <summary>
            Formats the token sequence to the writer
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlFormatter.Format(System.Xml.XmlWriter,System.Collections.Generic.IEnumerable{JsonFx.Serialization.Token{JsonFx.Markup.MarkupTokenType}})">
            <summary>
            Formats the token sequence to the writer
            </summary>
            <param name="writer"></param>
            <param name="tokens"></param>
        </member>
        <member name="T:JsonFx.Xml.XmlWriter.XmlFormatter.XmlWriterAdapter">
            <summary>
            Wraps an XmlWriter as a TextWriter
            </summary>
        </member>
        <member name="M:JsonFx.Xml.XmlWriter.XmlFormatter.XmlWriterAdapter.#ctor(System.Xml.XmlWriter)">
            <summary>
            Ctor
            </summary>
            <param name="writer"></param>
        </member>
        <member name="P:JsonFx.Xml.XmlWriter.XmlFormatter.XmlWriterAdapter.Writer">
            <summary>
            Gets the underlying XmlWriter
            </summary>
        </member>
        <member name="T:JsonFx.Xml.Resolvers.XmlResolverStrategy">
            <summary>
            Controls name resolution for IDataReader / IDataWriter using attributes and conventions similar to XmlSerializer semantics
            </summary>
            <remarks>
            http://msdn.microsoft.com/en-us/library/83y7df3e.aspx
            </remarks>
        </member>
        <member name="M:JsonFx.Xml.Resolvers.XmlResolverStrategy.IsPropertyIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Gets a value indicating if the property is to be serialized.
            </summary>
            <param name="member"></param>
            <param name="isImmutableType"></param>
            <returns></returns>
            <remarks>default implementation is must be read/write properties, or immutable</remarks>
        </member>
        <member name="M:JsonFx.Xml.Resolvers.XmlResolverStrategy.IsFieldIgnored(System.Reflection.FieldInfo)">
            <summary>
            Gets a value indicating if the field is to be serialized.
            </summary>
            <param name="member"></param>
            <returns></returns>
            <remarks>default implementation is must be public, non-readonly field</remarks>
        </member>
        <member name="M:JsonFx.Xml.Resolvers.XmlResolverStrategy.GetValueIgnoredCallback(System.Reflection.MemberInfo)">
            <summary>
            Gets a delegate which determines if the property or field should not be serialized based upon its value.
            </summary>
            <param name="member"></param>
            <returns>if has a value equivalent to the DefaultValueAttribute or has a property named XXXSpecified which determines visibility</returns>
            <remarks>
            This is useful when default values need not be serialized.
            Under these situations XmlSerializer ignores properties based upon value:
            - DefaultValue: http://msdn.microsoft.com/en-us/library/system.componentmodel.defaultvalueattribute.aspx
            - Specified Properies: http://msdn.microsoft.com/en-us/library/bb402199.aspx
            - ShouldSerialize Methods: http://msdn.microsoft.com/en-us/library/53b8022e.aspx
            </remarks>
        </member>
        <member name="M:JsonFx.Xml.Resolvers.XmlResolverStrategy.GetName(System.Reflection.MemberInfo)">
            <summary>
            Gets the serialized name for the member.
            </summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:JsonFx.Xml.Resolvers.XmlResolverStrategy.SortMembers(System.Collections.Generic.IEnumerable{JsonFx.Serialization.Resolvers.MemberMap})">
            <summary>
            Sorts members to ensure proper document order where attributes precede all child elements.
            </summary>
            <param name="members"></param>
            <returns></returns>
            <remarks>
            Performs the first stage of XML Canonicalization document order http://www.w3.org/TR/xml-c14n#DocumentOrder
            "An element's namespace and attribute nodes have a document order position greater than the element but less than any child node of the element."
            </remarks>
        </member>
        <member name="T:JsonFx.CodeGen.DynamicMethodGenerator">
            <summary>
            Generates delegates for getting/setting properties and field and invoking constructors
            </summary>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetGetter(System.Reflection.MemberInfo)">
            <summary>
            Creates a field getter delegate for the specified property or field
            </summary>
            <param name="memberInfo">PropertyInfo or FieldInfo</param>
            <returns>GetterDelegate for property or field, null otherwise</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetSetter(System.Reflection.MemberInfo)">
            <summary>
            Creates a field setter delegate for the specified property or field
            </summary>
            <param name="memberInfo">PropertyInfo or FieldInfo</param>
            <returns>SetterDelegate for property or field, null otherwise</returns>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetPropertyGetter(System.Reflection.PropertyInfo)">
            <summary>
            Creates a property getter delegate for the specified property
            </summary>
            <param name="propertyInfo"></param>
            <returns>GetterDelegate if property CanRead, otherwise null</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetPropertySetter(System.Reflection.PropertyInfo)">
            <summary>
            Creates a property setter delegate for the specified property
            </summary>
            <param name="propertyInfo"></param>
            <returns>GetterDelegate if property CanWrite, otherwise null</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetFieldGetter(System.Reflection.FieldInfo)">
            <summary>
            Creates a field getter delegate for the specified field
            </summary>
            <param name="fieldInfo"></param>
            <returns>GetterDelegate which returns field unless is enum in which will return enum value</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetFieldSetter(System.Reflection.FieldInfo)">
            <summary>
            Creates a field setter delegate for the specified field
            </summary>
            <param name="fieldInfo"></param>
            <returns>SetterDelegate unless field IsInitOnly then returns null</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetMethodProxy(System.Reflection.MethodInfo)">
            <summary>
            Creates a proxy delegate accepting a target instance and corresponding arguments
            </summary>
            <param name="methodInfo">method to proxy</param>
            <returns>ProxyDelegate or null if cannot be invoked</returns>
            <remarks>
            Note: use with caution this method will expose private and protected methods without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetTypeFactory(System.Type)">
            <summary>
            Creates a default constructor delegate
            </summary>
            <param name="type">type to be created</param>
            <returns>FactoryDelegate or null if default constructor not found</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetTypeFactory(System.Type,System.Type[])">
            <summary>
            Creates a constructor delegate accepting specified arguments
            </summary>
            <param name="type">type to be created</param>
            <param name="args">constructor arguments type list</param>
            <returns>FactoryDelegate or null if constructor not found</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
        <member name="M:JsonFx.CodeGen.DynamicMethodGenerator.GetTypeFactory(System.Reflection.ConstructorInfo)">
            <summary>
            Creates a constructor delegate accepting specified arguments
            </summary>
            <param name="type">type to be created</param>
            <param name="args">constructor arguments type list</param>
            <returns>FactoryDelegate or null if constructor not found</returns>
            <remarks>
            Note: use with caution this method will expose private and protected constructors without safety checks.
            </remarks>
        </member>
    </members>
</doc>
